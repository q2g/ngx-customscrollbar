{"hash":"69ed745358655b86c3e2f73b380ae8f52d32a2f2","fesm2020":{"code":"import * as i0 from '@angular/core';\nimport { Injectable, ElementRef, Component, Host, Optional, Inject, Input, HostBinding, ViewChild, Directive, NgModule } from '@angular/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { fromEvent, Subject, Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil as takeUntil$1, tap, switchMap, finalize, distinctUntilChanged, delay, filter } from 'rxjs/operators';\nimport { __decorate } from 'tslib';\nimport { takeUntil } from 'rxjs/internal/operators/takeUntil';\nimport * as i1 from '@angular/cdk/platform';\nimport { supportsScrollBehavior } from '@angular/cdk/platform';\n\nvar DomHelper;\r\n(function (DomHelper) {\r\n    /**\r\n     * get computed style from element\r\n     */\r\n    function getElementStyle(el, style) {\r\n        let styleValue;\r\n        try {\r\n            styleValue = getComputedStyle(el, null).getPropertyValue(style);\r\n        }\r\n        catch (e) {\r\n            styleValue = null;\r\n        }\r\n        return styleValue;\r\n    }\r\n    DomHelper.getElementStyle = getElementStyle;\r\n    function getMeasure(el) {\r\n        // get computed style not works that good and that fast like el.offsetHeight\r\n        return {\r\n            height: el.offsetHeight,\r\n            width: el.offsetWidth,\r\n            innerHeight: getInnerHeight(el),\r\n            innerWidth: getInnerWidth(el),\r\n            top: el.offsetTop,\r\n            left: el.offsetLeft\r\n        };\r\n    }\r\n    DomHelper.getMeasure = getMeasure;\r\n    function getScrollContainerMeasure(el) {\r\n        const elMeasure = getMeasure(el);\r\n        return {\r\n            ...elMeasure,\r\n            scrollHeight: el.scrollHeight,\r\n            scrollLeft: el.scrollLeft,\r\n            scrollTop: el.scrollTop,\r\n            scrollWidth: el.scrollWidth,\r\n        };\r\n    }\r\n    DomHelper.getScrollContainerMeasure = getScrollContainerMeasure;\r\n    /**\r\n     * get element inner height, without padding\r\n     */\r\n    function getInnerHeight(el) {\r\n        /** @todo this will called alot times on resize */\r\n        const computed = getComputedStyle(el, null);\r\n        const paddingTop = parseInt(computed.getPropertyValue(\"padding-top\"), 10);\r\n        const paddingBot = parseInt(computed.getPropertyValue(\"padding-bottom\"), 10);\r\n        return el.offsetHeight - paddingTop - paddingBot;\r\n    }\r\n    DomHelper.getInnerHeight = getInnerHeight;\r\n    /**\r\n     * get elment inner width without border, margin and padding\r\n     */\r\n    function getInnerWidth(el) {\r\n        /** @todo this will called alot times on resize */\r\n        const computed = getComputedStyle(el, null);\r\n        const paddingLeft = parseInt(computed.getPropertyValue(\"padding-left\"), 10);\r\n        const paddingRight = parseInt(computed.getPropertyValue(\"padding-right\"), 10);\r\n        return el.offsetWidth - paddingLeft - paddingRight;\r\n    }\r\n    DomHelper.getInnerWidth = getInnerWidth;\r\n    /**\r\n     * get element bounds\r\n     */\r\n    function getElementBounds(el) {\r\n        return el.getBoundingClientRect();\r\n    }\r\n    DomHelper.getElementBounds = getElementBounds;\r\n    /**\r\n     * calclulate offsetX / offsetY for MouseEvents\r\n     * we could use event.offsetX or event.offsetY but this is experimental\r\n     * and not working correctly in FF for some times.\r\n     */\r\n    function getMouseOffset(event) {\r\n        const rect = event.currentTarget.getBoundingClientRect();\r\n        return {\r\n            left: event.clientX - rect.left,\r\n            top: event.clientY - rect.top\r\n        };\r\n    }\r\n    DomHelper.getMouseOffset = getMouseOffset;\r\n})(DomHelper || (DomHelper = {}));\n\nfunction importData(target, key = null, descriptor) {\r\n    if (!descriptor) {\r\n        descriptor = Object.getOwnPropertyDescriptor(target, key);\r\n    }\r\n    const originalMethod = descriptor.value;\r\n    descriptor.value = function (data) {\r\n        // get all properties, exclude decorated property\r\n        Object.keys(data).forEach((property) => {\r\n            this[property] = data[property];\r\n        });\r\n        // call original descriptor\r\n        const result = originalMethod.call(this, data);\r\n        return result;\r\n    };\r\n    return descriptor;\r\n}\n\n/**\r\n * viewport model so save / share current state from viewport\r\n */\r\nclass ContainerMeasureModel {\r\n    constructor(data) {\r\n        this.setMeasures(data);\r\n    }\r\n    setMeasures(data) {\r\n        this._measure = data;\r\n    }\r\n    get measures() {\r\n        return { ...this._measure };\r\n    }\r\n    set innerHeight(value) {\r\n        this._innerHeight = value;\r\n    }\r\n    set innerWidth(value) {\r\n        this._innerWidth = value;\r\n    }\r\n    set height(value) {\r\n        this._height = value;\r\n    }\r\n    set width(value) {\r\n        this._width = value;\r\n    }\r\n    set top(value) {\r\n        this._top = value;\r\n    }\r\n    set left(value) {\r\n        this._left = value;\r\n    }\r\n    get innerHeight() {\r\n        return this._innerHeight;\r\n    }\r\n    /**\r\n     * @returns number\r\n     */\r\n    get innerWidth() {\r\n        return this._innerWidth;\r\n    }\r\n    get height() {\r\n        return this._height;\r\n    }\r\n    get width() {\r\n        return this._width;\r\n    }\r\n    get top() {\r\n        return this._top;\r\n    }\r\n    get left() {\r\n        return this._left;\r\n    }\r\n}\r\n__decorate([\r\n    importData\r\n], ContainerMeasureModel.prototype, \"setMeasures\", null);\n\nclass ScrollHelper {\r\n    constructor(thumbMeasure, trackMeasure, _viewportMeasure) {\r\n        this.thumbMeasure = thumbMeasure;\r\n        this.trackMeasure = trackMeasure;\r\n        this._viewportMeasure = _viewportMeasure;\r\n    }\r\n    set viewportMeasure(measure) {\r\n        this._viewportMeasure = measure;\r\n    }\r\n    get viewportMeasure() {\r\n        return this._viewportMeasure;\r\n    }\r\n    /**\r\n     * return true if we could skip scroll event otherwise false\r\n     */\r\n    couldSkipScrollEvent(direction, event) {\r\n        if (direction === \"vertical\" /* Y */ && event.scrolledY) {\r\n            return false;\r\n        }\r\n        if (direction === \"horizontal\" /* X */ && event.scrolledX) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\n\n/**\r\n * helper for calculations on vertical scrollbars\r\n */\r\nclass HorizontalScrollHelper extends ScrollHelper {\r\n    calculateScrollMax() {\r\n        return this.viewportMeasure.scrollWidth - this.viewportMeasure.width;\r\n    }\r\n    calculateThumbPosition() {\r\n        const left = this.viewportMeasure.scrollLeft;\r\n        const offsetLeft = left * this.calculateTrackMax() / this.calculateScrollMax();\r\n        this.thumbMeasure.left = offsetLeft;\r\n        return offsetLeft;\r\n    }\r\n    calculateDragDropScrollOffset(dragMove, dragDroffset, offset) {\r\n        const offsetLeft = dragMove.clientX - offset.left;\r\n        const trackMax = this.calculateTrackMax();\r\n        const scrollMax = this.calculateScrollMax();\r\n        const top = this.viewportMeasure.scrollTop;\r\n        const left = scrollMax * (offsetLeft - dragDroffset.left) / trackMax;\r\n        return { top, left };\r\n    }\r\n    calculateTrackMax() {\r\n        return this.trackMeasure.innerWidth - this.calculateThumbSize();\r\n    }\r\n    calculateThumbSize() {\r\n        const thumbSize = this.viewportMeasure.width * this.trackMeasure.innerWidth / this.viewportMeasure.scrollWidth;\r\n        return thumbSize < 20 ? 20 : thumbSize;\r\n    }\r\n    /**\r\n     * returns thumb transform property\r\n     */\r\n    getScrollThumbCssTransform() {\r\n        const left = this.calculateThumbPosition();\r\n        return {\r\n            style: \"transform\",\r\n            value: `translate3d(${left}px, 0, 0)`\r\n        };\r\n    }\r\n    getScrollThumbCssSize() {\r\n        const width = this.calculateThumbSize();\r\n        return { style: \"width\", value: `${width}px` };\r\n    }\r\n    isScrollable() {\r\n        return this.viewportMeasure.scrollWidth > this.viewportMeasure.width;\r\n    }\r\n    calculatePageScroll(offset) {\r\n        const modifier = offset.left < this.thumbMeasure.left\r\n            ? -1 /* BACK */\r\n            : 1 /* FORWARD */;\r\n        const scrollOffset = {\r\n            left: this.viewportMeasure.scrollLeft + (this.viewportMeasure.width * modifier),\r\n            top: this.viewportMeasure.scrollTop\r\n        };\r\n        return scrollOffset;\r\n    }\r\n}\n\nclass VerticalScrollHelper extends ScrollHelper {\r\n    /**\r\n     * calculate offset we have scrolled on viewport\r\n     */\r\n    calculateDragDropScrollOffset(dragMove, dragStartOffset, offset) {\r\n        const offsetTop = dragMove.clientY - offset.top;\r\n        /** @TODO dont calculate this every time, this will not change on drag drop */\r\n        const trackMax = this.calculateTrackMax();\r\n        /** @TODO dont calculate this every time, this will not change on drag drop */\r\n        const scrollMax = this.calculateScrollMax();\r\n        const top = scrollMax * (offsetTop - dragStartOffset.top) / trackMax;\r\n        const left = this.viewportMeasure.scrollLeft;\r\n        return { top, left };\r\n    }\r\n    /**\r\n     * calculate max scroll position on viewport\r\n     */\r\n    calculateScrollMax() {\r\n        return this.viewportMeasure.scrollHeight - this.viewportMeasure.height;\r\n    }\r\n    /**\r\n     * calculate max track position for scrollThumb\r\n     */\r\n    calculateTrackMax() {\r\n        return this.trackMeasure.innerHeight - this.calculateThumbSize();\r\n    }\r\n    /**\r\n     * calculate thumbnail size\r\n     */\r\n    calculateThumbSize() {\r\n        const thumbSize = this.viewportMeasure.height * this.trackMeasure.innerHeight / this.viewportMeasure.scrollHeight;\r\n        return thumbSize < 20 ? 20 : thumbSize;\r\n    }\r\n    /**\r\n     * calculate scrollthumb position, set position for thumb\r\n     */\r\n    calculateThumbPosition() {\r\n        const top = this.viewportMeasure.scrollTop;\r\n        const valueTop = top * this.calculateTrackMax() / this.calculateScrollMax();\r\n        this.thumbMeasure.top = valueTop;\r\n        return valueTop;\r\n    }\r\n    /**\r\n     * returns thumb transform property\r\n     */\r\n    getScrollThumbCssTransform() {\r\n        const top = this.calculateThumbPosition();\r\n        return {\r\n            style: \"transform\",\r\n            value: `translate3d(0, ${top}px, 0)`\r\n        };\r\n    }\r\n    getScrollThumbCssSize() {\r\n        const height = this.calculateThumbSize();\r\n        return { style: \"height\", value: `${height}px` };\r\n    }\r\n    isScrollable() {\r\n        return this.viewportMeasure.scrollHeight > this.viewportMeasure.height;\r\n    }\r\n    calculatePageScroll(offset) {\r\n        const modifier = offset.top < this.thumbMeasure.top\r\n            ? -1 /* BACK */\r\n            : 1 /* FORWARD */;\r\n        const scrollOffset = {\r\n            top: this.viewportMeasure.scrollTop + (this.viewportMeasure.height * modifier),\r\n            left: this.viewportMeasure.scrollLeft\r\n        };\r\n        return scrollOffset;\r\n    }\r\n}\n\nclass ScrollContainerMeasureModel extends ContainerMeasureModel {\r\n    /**\r\n     * set measure data automatically imports data\r\n     * to model\r\n     */\r\n    setMeasures(data) {\r\n        super.setMeasures(data);\r\n    }\r\n    set scrollHeight(value) {\r\n        this._scrollHeight = value;\r\n    }\r\n    set scrollLeft(value) {\r\n        this._scrollLeft = value;\r\n    }\r\n    set scrollTop(value) {\r\n        this._scrollTop = value;\r\n    }\r\n    set scrollWidth(value) {\r\n        this._scrollWidth = value;\r\n    }\r\n    get scrollHeight() {\r\n        return this._scrollHeight;\r\n    }\r\n    get scrollLeft() {\r\n        return this._scrollLeft;\r\n    }\r\n    get scrollTop() {\r\n        return this._scrollTop;\r\n    }\r\n    get scrollWidth() {\r\n        return this._scrollWidth;\r\n    }\r\n}\r\n__decorate([\r\n    importData\r\n], ScrollContainerMeasureModel.prototype, \"setMeasures\", null);\n\n/**\r\n *\r\n */\r\nclass WindowResize {\r\n    constructor(zone) {\r\n        this.zone = zone;\r\n        /**\r\n         * current subscriber count on shared stream, the first subscriber\r\n         * will trigger shared stream registration on window resize stream\r\n         * if all subscribers are removed we automatically remove from\r\n         */\r\n        this.subscriberCount = 0;\r\n        this.windowResize$ = fromEvent(window, \"resize\");\r\n        this.shared$ = new Subject();\r\n    }\r\n    /**\r\n     * create shared event stream and register to this\r\n     */\r\n    onChange() {\r\n        // subscribe\r\n        return Observable.create(observer => {\r\n            this.subscriberCount++;\r\n            const event$ = this.shared$.subscribe(observer);\r\n            if (this.subscriberCount === 1) {\r\n                this.subscribeToWindowResizeEvent();\r\n            }\r\n            // unsubscribe\r\n            return () => {\r\n                event$.unsubscribe();\r\n                this.subscriberCount--;\r\n                if (this.subscriberCount <= 0) {\r\n                    this.resizeSubscription.unsubscribe();\r\n                }\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * register to window resize events\r\n     */\r\n    subscribeToWindowResizeEvent() {\r\n        this.zone.runOutsideAngular(() => {\r\n            this.resizeSubscription = this.windowResize$\r\n                .pipe(debounceAnimationFrame())\r\n                .subscribe(() => this.shared$.next());\r\n        });\r\n    }\r\n}\r\n/** @nocollapse */ WindowResize.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: WindowResize, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ WindowResize.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: WindowResize, providedIn: \"root\" });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: WindowResize, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: \"root\" }]\r\n        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });\r\nfunction debounceAnimationFrame() {\r\n    return function (source$) {\r\n        let resizeFired = false;\r\n        let drawing = false;\r\n        const requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame;\r\n        const obs = new Observable((observer) => {\r\n            function drawResize() {\r\n                if (resizeFired === true) {\r\n                    resizeFired = false;\r\n                    requestAnimationFrame(() => {\r\n                        observer.next();\r\n                        drawResize();\r\n                    });\r\n                }\r\n                else {\r\n                    drawing = false;\r\n                }\r\n            }\r\n            source$.subscribe(() => {\r\n                if (drawing === false) {\r\n                    resizeFired = true;\r\n                    drawResize();\r\n                }\r\n            });\r\n        });\r\n        return obs;\r\n    };\r\n}\n\n/**\r\n * viewport contol service, the glue between scrollbars and the viewport\r\n */\r\nclass ViewportControl {\r\n    constructor(resize) {\r\n        this.resize = resize;\r\n        this.destroy$ = new Subject();\r\n        this.scrollbars = new Set();\r\n        this.scrollPosition = {\r\n            vertical: 0,\r\n            horizontal: 0\r\n        };\r\n        this.viewportUpdate$ = new Subject();\r\n        this.viewportReady$ = new ReplaySubject(1);\r\n        this.viewportScroll$ = new Subject();\r\n        this.registerEvents();\r\n    }\r\n    /**\r\n     * inject the viewport which should be scrolled\r\n     */\r\n    set viewPort(viewPort) {\r\n        if (this.scrollbarViewPort && this.scrollbarViewPort === viewPort) {\r\n            return;\r\n        }\r\n        if (this.scrollSub) {\r\n            this.scrollSub.unsubscribe();\r\n        }\r\n        this.scrollbarViewPort = viewPort;\r\n        this.scrollSub = this.scrollbarViewPort.onScrolled()\r\n            .pipe(takeUntil(this.destroy$))\r\n            .subscribe(() => {\r\n            this.onScrolled();\r\n        });\r\n        this.scrollbarViewPort.control = this;\r\n        /** create new viewport model if a viewport has been bound */\r\n        this.viewportModel = new ScrollContainerMeasureModel(this.scrollbarViewPort.measureSize());\r\n        this.viewportReady$.next(this.viewportModel);\r\n        this.scrollbarViewPort.init();\r\n    }\r\n    /**\r\n     * register scrollbar to viewport so we could render them\r\n     * programatically if we need to do\r\n     */\r\n    addScrollbar(scrollbar) {\r\n        if (!this.scrollbars.has(scrollbar)) {\r\n            this.scrollbars.add(scrollbar);\r\n        }\r\n    }\r\n    /**\r\n     * remove scrollbar to viewport\r\n     */\r\n    removeScrollbar(scrollbar) {\r\n        if (this.scrollbars.has(scrollbar)) {\r\n            this.scrollbars.delete(scrollbar);\r\n        }\r\n    }\r\n    get viewportDimension() {\r\n        return this.viewportModel.measures;\r\n    }\r\n    get disabled() {\r\n        return this._disabled || false;\r\n    }\r\n    /**\r\n     * scroll page by specific amount\r\n     * move this to helper\r\n     */\r\n    scrollPage(direction) {\r\n        const pageSize = this.viewportDimension.height;\r\n        const scrollTop = this.viewportDimension.scrollTop + pageSize * direction;\r\n        this.scrollTo(this.sanitizeScrollPosition({ left: 0, top: scrollTop }));\r\n    }\r\n    /** not called if i just reload this */\r\n    ngOnDestroy() {\r\n        this.scrollbarViewPort.destroy();\r\n        this.destroy$.next(true);\r\n        this.viewportReady$.complete();\r\n        this.viewportUpdate$.complete();\r\n        this.destroy$.complete();\r\n        this.scrollbars.clear();\r\n        this.viewportModel = null;\r\n        this.scrollbars = null;\r\n    }\r\n    onLoad() {\r\n        return this.viewportReady$.asObservable();\r\n    }\r\n    onScroll() {\r\n        return this.viewportScroll$.asObservable();\r\n    }\r\n    /**\r\n     * returns observable to get notified if viewport\r\n     * has been changed in scroll or has been refreshed\r\n     */\r\n    onUpdate() {\r\n        return this.viewportUpdate$.asObservable();\r\n    }\r\n    /**\r\n     * viewport was changed, this could happen if new content, or window has been resized\r\n     * has been added or removed\r\n     */\r\n    update() {\r\n        /** triggers soft update to trigger directives */\r\n        this.viewportModel.setMeasures(this.scrollbarViewPort.measureSize());\r\n        this.emitUpdate({ type: \"viewport_update\" /* UPDATE */ });\r\n        /** get size again and trigger update for scrollbars */\r\n        this.viewportModel.setMeasures(this.scrollbarViewPort.measureSize());\r\n        this.scrollbars.forEach((scrollbar) => scrollbar.render());\r\n    }\r\n    /**\r\n     * viewport should scroll by specific amount\r\n     */\r\n    scrollTo(scrolledTo) {\r\n        this.scrollbarViewPort.scrollTo(this.sanitizeScrollPosition(scrolledTo));\r\n    }\r\n    /**\r\n     * scroll viewport to origin\r\n     */\r\n    reset() {\r\n        this.scrollTo({\r\n            top: 0,\r\n            left: 0\r\n        });\r\n    }\r\n    disableScroll(disabled) {\r\n        this._disabled = disabled;\r\n    }\r\n    registerEvents() {\r\n        this.resize.onChange()\r\n            .pipe(takeUntil(this.destroy$))\r\n            .subscribe(() => this.update());\r\n    }\r\n    /**\r\n     * viewport has been scrolled\r\n     */\r\n    onScrolled() {\r\n        const scrolled = this.scrollbarViewPort.scrolledOffset;\r\n        const scrolledY = this.scrollPosition.vertical !== scrolled.top;\r\n        const scrolledX = this.scrollPosition.horizontal !== scrolled.left;\r\n        // update model to set current scroll offsets\r\n        this.viewportModel.scrollLeft = scrolled.left;\r\n        this.viewportModel.scrollTop = scrolled.top;\r\n        this.viewportScroll$.next({\r\n            scrolledY,\r\n            scrolledX,\r\n            type: \"viewport_scrolled\" /* SCROLLED */\r\n        });\r\n        this.scrollPosition.vertical = scrolled.top;\r\n        this.scrollPosition.horizontal = scrolled.left;\r\n    }\r\n    /**\r\n     * emits an update event through viewportUpdate observable\r\n     */\r\n    emitUpdate(event) {\r\n        this.viewportUpdate$.next(event);\r\n    }\r\n    /**\r\n     * sanitize scroll position to ensure we not scroll over the bounds\r\n     */\r\n    sanitizeScrollPosition(scrollTo) {\r\n        const scrollMaxY = this.viewportModel.scrollHeight - this.viewportModel.height;\r\n        const scrollMaxX = this.viewportModel.scrollWidth - this.viewportModel.width;\r\n        const { top, left } = scrollTo;\r\n        return {\r\n            top: top < 0 ? 0 : top > scrollMaxY ? scrollMaxY : top,\r\n            left: left < 0 ? 0 : left > scrollMaxX ? scrollMaxX : left,\r\n        };\r\n    }\r\n}\r\n/** @nocollapse */ ViewportControl.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: ViewportControl, deps: [{ token: WindowResize }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ ViewportControl.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: ViewportControl });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: ViewportControl, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: WindowResize }]; } });\n\nclass NgxCustomScrollbarComponent {\r\n    constructor(viewportController, document, hostEl, ngZone, renderer) {\r\n        this.viewportController = viewportController;\r\n        this.document = document;\r\n        this.hostEl = hostEl;\r\n        this.ngZone = ngZone;\r\n        this.renderer = renderer;\r\n        this.scrollDirection = \"vertical\" /* Y */;\r\n        this.isDestroyed$ = new Subject();\r\n    }\r\n    /**\r\n     * initialize scrollbar track and scrollbar thumb events\r\n     */\r\n    ngOnInit() {\r\n        this.ngZone.runOutsideAngular(() => {\r\n            this.registerThumbEvents()\r\n                .pipe(takeUntil$1(this.isDestroyed$))\r\n                .subscribe();\r\n            this.registerScrollTrackEvents();\r\n        });\r\n    }\r\n    /**\r\n     * dom is rendered and initialized\r\n     */\r\n    ngAfterViewInit() {\r\n        this.viewportController.addScrollbar(this);\r\n        /** viewport has been attached */\r\n        this.viewportController.onLoad()\r\n            .pipe(takeUntil$1(this.isDestroyed$))\r\n            .subscribe((measure) => this.handleViewportLoaded(measure));\r\n        /** viewport has been updated in size or is scrolled */\r\n        this.viewportController.onScroll()\r\n            .pipe(takeUntil$1(this.isDestroyed$))\r\n            .subscribe((event) => this.handleViewportScroll(event));\r\n    }\r\n    /**\r\n     * compoenent gets destroyed remove\r\n     * emit true to isDestroyed to remove subscriptions\r\n     * from all streams\r\n     */\r\n    ngOnDestroy() {\r\n        this.viewportController.removeScrollbar(this);\r\n        this.isDestroyed$.next(true);\r\n        this.isDestroyed$.complete();\r\n        this.scrollHelper = null;\r\n        this.thumbMeasure = null;\r\n        this.trackMeasure = null;\r\n        this.viewportMeasure = null;\r\n    }\r\n    render() {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n        const track = this.scrollbarTrack.nativeElement;\r\n        this.renderer.setStyle(thumb, \"display\", \"none\");\r\n        this.trackMeasure.setMeasures(DomHelper.getMeasure(track));\r\n        this.thumbMeasure.setMeasures(DomHelper.getMeasure(thumb));\r\n        this.renderScrollbarThumb();\r\n        this.moveThumbToPosition();\r\n    }\r\n    /**\r\n     * a viewport has been added to viewport controller\r\n     */\r\n    handleViewportLoaded(measure) {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n        const track = this.scrollbarTrack.nativeElement;\r\n        this.thumbMeasure = new ContainerMeasureModel(DomHelper.getMeasure(thumb));\r\n        this.trackMeasure = new ContainerMeasureModel(DomHelper.getMeasure(track));\r\n        this.viewportMeasure = measure;\r\n        this.initializeScrollHelper();\r\n        this.renderScrollbarThumb();\r\n        this.moveThumbToPosition();\r\n    }\r\n    /**\r\n     * viewportControl sends update, this could be\r\n     * initialized, scrolled or content changes\r\n     */\r\n    handleViewportScroll(event) {\r\n        if (this.scrollHelper.couldSkipScrollEvent(this.scrollDirection, event)) {\r\n            return;\r\n        }\r\n        this.renderScrollbarThumb();\r\n        this.moveThumbToPosition();\r\n    }\r\n    /**\r\n     * initialize scroll helpers\r\n     */\r\n    initializeScrollHelper() {\r\n        if (!this.scrollHelper) {\r\n            const scrollHelperConstructor = this.scrollDirection === \"horizontal\" /* X */\r\n                ? HorizontalScrollHelper\r\n                : VerticalScrollHelper;\r\n            this.scrollHelper = new scrollHelperConstructor(this.thumbMeasure, this.trackMeasure, this.viewportMeasure);\r\n        }\r\n        else {\r\n            this.scrollHelper.viewportMeasure = this.viewportMeasure;\r\n        }\r\n    }\r\n    /**\r\n     * renders scrollbar thumb\r\n     */\r\n    renderScrollbarThumb() {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n        if (!this.scrollHelper.isScrollable()) {\r\n            this.renderer.setStyle(thumb, \"display\", \"none\");\r\n        }\r\n        else {\r\n            const cssSize = this.scrollHelper.getScrollThumbCssSize();\r\n            this.renderer.removeStyle(thumb, \"display\");\r\n            this.renderer.setStyle(thumb, cssSize.style, cssSize.value);\r\n        }\r\n    }\r\n    /**\r\n     * move thumb to position after viewport has been scrolled\r\n     */\r\n    moveThumbToPosition() {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n        const scrollCSS = this.scrollHelper.getScrollThumbCssTransform();\r\n        this.renderer.setStyle(thumb, scrollCSS.style, scrollCSS.value);\r\n    }\r\n    /**\r\n     * register scrollbar track click event to scroll a page\r\n     */\r\n    registerScrollTrackEvents() {\r\n        const track = this.scrollbarTrack.nativeElement;\r\n        fromEvent(track, \"click\")\r\n            .pipe(takeUntil$1(this.isDestroyed$))\r\n            .subscribe((event) => {\r\n            if (event.target === this.scrollbarThumb.nativeElement) {\r\n                return false;\r\n            }\r\n            const offset = this.scrollHelper.calculatePageScroll(DomHelper.getMouseOffset(event));\r\n            this.viewportController.scrollTo(offset);\r\n        });\r\n    }\r\n    /**\r\n     * handle drag drop on scrollbar thumb\r\n     */\r\n    registerThumbEvents() {\r\n        const mouseDown$ = fromEvent(this.scrollbarThumb.nativeElement, \"mousedown\");\r\n        const mouseMove$ = fromEvent(this.document, \"mousemove\");\r\n        const mouseUp$ = fromEvent(window, \"mouseup\");\r\n        const dragDrop$ = mouseDown$.pipe(tap(() => this.document.onselectstart = () => false), switchMap((dragStart) => {\r\n            const offset = DomHelper.getElementBounds(this.scrollbarTrack.nativeElement);\r\n            const dragOffset = DomHelper.getMouseOffset(dragStart);\r\n            this.renderer.addClass(this.hostEl.nativeElement, \"dragged\");\r\n            /** switch to mousemove stream until we press mouse button */\r\n            return mouseMove$.pipe(tap((dragMove) => {\r\n                this.viewportController.scrollTo(this.scrollHelper.calculateDragDropScrollOffset(dragMove, dragOffset, offset));\r\n            }), finalize(() => {\r\n                this.document.onselectstart = null;\r\n                this.renderer.removeClass(this.hostEl.nativeElement, \"dragged\");\r\n            }), takeUntil$1(mouseUp$));\r\n        }));\r\n        return dragDrop$.pipe(takeUntil$1(this.isDestroyed$));\r\n    }\r\n}\r\n/** @nocollapse */ NgxCustomScrollbarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarComponent, deps: [{ token: ViewportControl, host: true, optional: true }, { token: DOCUMENT }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });\r\n/** @nocollapse */ NgxCustomScrollbarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.3.6\", type: NgxCustomScrollbarComponent, selector: \"ngx-customscrollbar\", inputs: { scrollDirection: \"scrollDirection\" }, host: { properties: { \"class\": \"this.scrollDirection\", \"class.ngx-customscrollbars\": \"this.scrollDirection\" } }, viewQueries: [{ propertyName: \"scrollbarTrack\", first: true, predicate: [\"scrollbarTrack\"], descendants: true, read: ElementRef, static: true }, { propertyName: \"scrollbarThumb\", first: true, predicate: [\"scrollbarThumb\"], descendants: true, read: ElementRef, static: true }], ngImport: i0, template: \"<div class=\\\"scrollbar-up\\\" #scrollbarTopLeft></div>\\r\\n<div class=\\\"scrollbar-track\\\" #scrollbarTrack>\\r\\n    <div class=\\\"scrollbar-thumb\\\" #scrollbarThumb></div>\\r\\n</div>\\r\\n<div class=\\\"scrollbar-up\\\" #scrollbarRightBottom></div>\\r\\n\", styles: [\":host{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;display:flex}:host.vertical{-moz-flex-direction:column;flex-direction:column}:host.vertical .scrollbar-thumb{width:100%}:host.horizontal{-moz-flex-direction:row;flex-direction:row}:host.horizontal .scrollbar-thumb{height:100%}:host .scrollbar-track{flex:1}\\n\"] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarComponent, decorators: [{\r\n            type: Component,\r\n            args: [{ selector: \"ngx-customscrollbar\", template: \"<div class=\\\"scrollbar-up\\\" #scrollbarTopLeft></div>\\r\\n<div class=\\\"scrollbar-track\\\" #scrollbarTrack>\\r\\n    <div class=\\\"scrollbar-thumb\\\" #scrollbarThumb></div>\\r\\n</div>\\r\\n<div class=\\\"scrollbar-up\\\" #scrollbarRightBottom></div>\\r\\n\", styles: [\":host{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;display:flex}:host.vertical{-moz-flex-direction:column;flex-direction:column}:host.vertical .scrollbar-thumb{width:100%}:host.horizontal{-moz-flex-direction:row;flex-direction:row}:host.horizontal .scrollbar-thumb{height:100%}:host .scrollbar-track{flex:1}\\n\"] }]\r\n        }], ctorParameters: function () { return [{ type: ViewportControl, decorators: [{\r\n                    type: Host\r\n                }, {\r\n                    type: Optional\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }]; }, propDecorators: { scrollDirection: [{\r\n                type: Input\r\n            }, {\r\n                type: HostBinding,\r\n                args: [\"class\"]\r\n            }, {\r\n                type: HostBinding,\r\n                args: [\"class.ngx-customscrollbars\"]\r\n            }], scrollbarTrack: [{\r\n                type: ViewChild,\r\n                args: [\"scrollbarTrack\", { read: ElementRef, static: true }]\r\n            }], scrollbarThumb: [{\r\n                type: ViewChild,\r\n                args: [\"scrollbarThumb\", { read: ElementRef, static: true }]\r\n            }] } });\n\n/**\r\n * dont show element if we can support styles of scrollbar\r\n * only via css. Possible with webkit / BLINK (chrome, chromium, opera)\r\n */\r\nclass NgxCustomScrollbarHideOnNativeStyleDirective {\r\n    constructor(\r\n    /** The view container to add items to. */\r\n    viewContainerRef, \r\n    /** The template to use when stamping out new items. */\r\n    template, \r\n    /** platform */\r\n    platform) {\r\n        this.viewContainerRef = viewContainerRef;\r\n        this.template = template;\r\n        this.platform = platform;\r\n    }\r\n    set q2gScrollbarHideOnNativeStyle(hideOnNative) {\r\n        if (!this.platform.WEBKIT && !this.platform.BLINK || hideOnNative === false) {\r\n            this.viewContainerRef.createEmbeddedView(this.template);\r\n        }\r\n        else {\r\n            this.viewContainerRef.clear();\r\n        }\r\n    }\r\n}\r\n/** @nocollapse */ NgxCustomScrollbarHideOnNativeStyleDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarHideOnNativeStyleDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: i1.Platform }], target: i0.ɵɵFactoryTarget.Directive });\r\n/** @nocollapse */ NgxCustomScrollbarHideOnNativeStyleDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.6\", type: NgxCustomScrollbarHideOnNativeStyleDirective, selector: \"[ngxCustomScrollbarHideOnNativeStyle]\", inputs: { q2gScrollbarHideOnNativeStyle: \"q2gScrollbarHideOnNativeStyle\" }, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarHideOnNativeStyleDirective, decorators: [{\r\n            type: Directive,\r\n            args: [{ selector: \"[ngxCustomScrollbarHideOnNativeStyle]\" }]\r\n        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: i1.Platform }]; }, propDecorators: { q2gScrollbarHideOnNativeStyle: [{\r\n                type: Input\r\n            }] } });\n\nclass Viewport {\r\n    constructor() {\r\n        this.viewportScrolledOffset = { top: 0, left: 0 };\r\n        this.scrolled$ = new Subject();\r\n    }\r\n    destroy() { }\r\n    init() { }\r\n    set control(control) {\r\n        this.viewPortController = control;\r\n    }\r\n    get control() {\r\n        return this.viewPortController;\r\n    }\r\n    reset() {\r\n        this.scrollTo({ top: 0, left: 0 });\r\n    }\r\n    onScrolled() {\r\n        return this.scrolled$.asObservable();\r\n    }\r\n}\n\nclass HtmlViewport extends Viewport {\r\n    constructor(zone, element) {\r\n        super();\r\n        this.zone = zone;\r\n        this.element = element;\r\n        this.isDestroyed = false;\r\n        this.destroy$ = new Subject();\r\n    }\r\n    /** element is bound to viewport */\r\n    init() {\r\n        this.scroll$ = fromEvent(this.element, \"scroll\")\r\n            .pipe(takeUntil$1(this.destroy$));\r\n        this.registerEvents();\r\n    }\r\n    destroy() {\r\n        /**\r\n         * component gets allready destroyed\r\n         * could happens twice if we create this with directive which destroys the viewport\r\n         * or we destroy the whole component which provides viewport control\r\n         */\r\n        if (this.isDestroyed) {\r\n            return;\r\n        }\r\n        this.destroy$.next(true);\r\n        this.destroy$.complete();\r\n        this.isDestroyed = true;\r\n    }\r\n    /**\r\n     * get container dimensions\r\n     */\r\n    measureSize() {\r\n        return DomHelper.getScrollContainerMeasure(this.element);\r\n    }\r\n    /**\r\n     * scroll viewport to specific position\r\n     */\r\n    scrollTo(offset) {\r\n        if (supportsScrollBehavior()) {\r\n            this.element.scrollTo(offset);\r\n        }\r\n        else {\r\n            const { top, left } = offset;\r\n            if (left || left === 0) {\r\n                this.element.scrollLeft = left;\r\n            }\r\n            if (top || top === 0) {\r\n                this.element.scrollTop = top;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * get scrolled offset\r\n     */\r\n    get scrolledOffset() {\r\n        return {\r\n            top: this.element.scrollTop,\r\n            left: this.element.scrollLeft\r\n        };\r\n    }\r\n    /**\r\n     * register to scroll event on html node\r\n     */\r\n    registerEvents() {\r\n        this.zone.runOutsideAngular(() => {\r\n            this.scroll$.subscribe(() => {\r\n                if (!this.viewPortController.disabled) {\r\n                    this.scrolled$.next();\r\n                    return;\r\n                }\r\n                this.scrollTo({ left: 0, top: 0 });\r\n            });\r\n        });\r\n    }\r\n}\n\nvar CHANGE_DETECTION_STRATEGY;\r\n(function (CHANGE_DETECTION_STRATEGY) {\r\n    CHANGE_DETECTION_STRATEGY[\"CHECKED\"] = \"checked\";\r\n    CHANGE_DETECTION_STRATEGY[\"INPUT\"] = \"input\";\r\n    CHANGE_DETECTION_STRATEGY[\"MUTATION\"] = \"mutation\";\r\n})(CHANGE_DETECTION_STRATEGY || (CHANGE_DETECTION_STRATEGY = {}));\r\n/**\r\n * directive for html elements\r\n * this will wrap the html element into HtmlViewport\r\n */\r\nclass NgxCustomScrollbarScrollableDirective {\r\n    constructor(viewportControl, zone, el, renderer) {\r\n        this.viewportControl = viewportControl;\r\n        this.zone = zone;\r\n        this.el = el;\r\n        this.renderer = renderer;\r\n        this.update$ = new Subject();\r\n        this.changeDetection = CHANGE_DETECTION_STRATEGY.CHECKED;\r\n        this.destroyed$ = new Subject();\r\n        this.oldScrollDimension = null;\r\n    }\r\n    set changeDetectionStrategy(strategy) {\r\n        if (strategy) {\r\n            this.changeDetection = strategy;\r\n        }\r\n    }\r\n    ngOnInit() {\r\n        this.renderer.addClass(this.el.nativeElement, \"ngx-customscrollbar--html-viewport\");\r\n        this.update$.pipe(distinctUntilChanged(), delay(100), filter((newSize) => {\r\n            const hasChanged = JSON.stringify(newSize) !== JSON.stringify(this.scrollSize);\r\n            this.scrollSize = newSize;\r\n            return hasChanged;\r\n        }), takeUntil$1(this.destroyed$)).subscribe({\r\n            next: () => this.viewportControl.update()\r\n        });\r\n        switch (this.changeDetection) {\r\n            case CHANGE_DETECTION_STRATEGY.INPUT:\r\n                this.initInputChangeDetection();\r\n                break;\r\n        }\r\n    }\r\n    ngAfterViewChecked() {\r\n        if (this.changeDetection === CHANGE_DETECTION_STRATEGY.CHECKED) {\r\n            const newScrollDimension = this.getScrollDimension();\r\n            if (this.oldScrollDimension && JSON.stringify(this.oldScrollDimension) === JSON.stringify(newScrollDimension)) {\r\n                return;\r\n            }\r\n            this.oldScrollDimension = newScrollDimension;\r\n            this.update$.next(newScrollDimension);\r\n        }\r\n    }\r\n    /**\r\n     * if component gets destroyed tell our control we gets destroyed\r\n     * and remove from dom mutations\r\n     *\r\n     * @memberof ScrollableContainerDirective\r\n     */\r\n    ngOnDestroy() {\r\n        this.htmlViewport.destroy();\r\n        this.viewportControl = null;\r\n        this.update$.complete();\r\n        this.update$ = null;\r\n        this.destroyed$.next(true);\r\n        this.destroyed$.complete();\r\n        this.destroyed$ = null;\r\n    }\r\n    /**\r\n     * start watching the dom after view has been initialized\r\n     * this ensures initial data has allready been set.\r\n     *\r\n     * We only want to know if we add or remove some items\r\n     *\r\n     * @memberof ScrollableContainerDirective\r\n     */\r\n    ngAfterViewInit() {\r\n        this.scrollSize = this.getScrollDimension();\r\n        this.htmlViewport = new HtmlViewport(this.zone, this.el.nativeElement);\r\n        this.viewportControl.viewPort = this.htmlViewport;\r\n    }\r\n    /**\r\n     * get scroll dimensions\r\n     */\r\n    getScrollDimension() {\r\n        return {\r\n            scrollHeight: this.el.nativeElement.scrollHeight,\r\n            scrollWidth: this.el.nativeElement.scrollWidth\r\n        };\r\n    }\r\n    initInputChangeDetection() {\r\n        fromEvent(this.el.nativeElement, \"input\")\r\n            .pipe(takeUntil$1(this.destroyed$))\r\n            .subscribe({\r\n            next: () => this.update$.next(this.getScrollDimension())\r\n        });\r\n    }\r\n}\r\n/** @nocollapse */ NgxCustomScrollbarScrollableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarScrollableDirective, deps: [{ token: ViewportControl, host: true }, { token: i0.NgZone }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });\r\n/** @nocollapse */ NgxCustomScrollbarScrollableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.6\", type: NgxCustomScrollbarScrollableDirective, selector: \"[ngxCustomScrollbarScrollable]\", inputs: { changeDetectionStrategy: [\"ngxCustomScrollbarScrollable\", \"changeDetectionStrategy\"] }, exportAs: [\"ngxCustomScrollbarHTMLViewport\"], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarScrollableDirective, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: \"[ngxCustomScrollbarScrollable]\",\r\n                    exportAs: \"ngxCustomScrollbarHTMLViewport\"\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: ViewportControl, decorators: [{\r\n                    type: Host\r\n                }] }, { type: i0.NgZone }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { changeDetectionStrategy: [{\r\n                type: Input,\r\n                args: [\"ngxCustomScrollbarScrollable\"]\r\n            }] } });\n\nclass Overflow {\r\n}\r\nOverflow.NONE = \"none\";\r\nOverflow.AUTO = \"auto\";\r\nOverflow.SCROLL = \"scroll\";\n\n/**\r\n * remove component if we dont need to scroll anymore, and\r\n * show it again if we can scroll. Same as css overflow: auto\r\n */\r\nclass NgxCustomScrollbarOverflow {\r\n    constructor(\r\n    /** The view container to add items to. */\r\n    viewContainerRef, \r\n    /** The template to use when stamping out new items. */\r\n    template, \r\n    /** viewport control to bound */\r\n    viewportController, changeDetector) {\r\n        this.viewContainerRef = viewContainerRef;\r\n        this.template = template;\r\n        this.viewportController = viewportController;\r\n        this.changeDetector = changeDetector;\r\n        this.overflow = Overflow.SCROLL;\r\n        this.isViewportVisible = false;\r\n        this.needsUpdate = false;\r\n        this.destroyed$ = new Subject();\r\n    }\r\n    /**\r\n     * angular change detection hook\r\n     */\r\n    ngDoCheck() {\r\n        if (this.needsUpdate) {\r\n            this.toggleScrollbar();\r\n        }\r\n        this.needsUpdate = false;\r\n    }\r\n    /**\r\n     * scrollbar gets destroyed\r\n     */\r\n    ngOnDestroy() {\r\n        this.destroyed$.next(true);\r\n    }\r\n    /**\r\n     * register on viewportControl onUpdate event\r\n     * and check scrollbar for visibility\r\n     */\r\n    ngOnInit() {\r\n        this.viewportController.onLoad().pipe(tap(() => this.checkScrollbarNeedsUpdate()), switchMap(() => this.viewportController.onUpdate()), takeUntil$1(this.destroyed$)).subscribe((updateEvent) => {\r\n            const event = updateEvent.type;\r\n            const checkUpdate = event === \"viewport_update\" /* UPDATE */;\r\n            if (checkUpdate) {\r\n                this.checkScrollbarNeedsUpdate();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * check for updates on scrollbar\r\n     */\r\n    checkScrollbarNeedsUpdate() {\r\n        let isOverflow;\r\n        switch (this.overflow) {\r\n            case Overflow.NONE:\r\n                isOverflow = false;\r\n                break;\r\n            case Overflow.SCROLL:\r\n                isOverflow = true;\r\n                break;\r\n            default: isOverflow = this.hasOverflow(this.viewportController.viewportDimension);\r\n        }\r\n        this.needsUpdate = isOverflow !== this.isViewportVisible;\r\n        this.isViewportVisible = isOverflow;\r\n        if (this.needsUpdate) {\r\n            this.changeDetector.detectChanges();\r\n        }\r\n    }\r\n    /**\r\n     * toggle scrollbar visibility, clears viewport\r\n     * if scrollbar should be hidden now\r\n     */\r\n    toggleScrollbar() {\r\n        if (this.isViewportVisible) {\r\n            this.viewContainerRef.createEmbeddedView(this.template);\r\n        }\r\n        else {\r\n            this.viewContainerRef.clear();\r\n        }\r\n    }\r\n}\r\n/** @nocollapse */ NgxCustomScrollbarOverflow.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarOverflow, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: ViewportControl, host: true }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });\r\n/** @nocollapse */ NgxCustomScrollbarOverflow.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.6\", type: NgxCustomScrollbarOverflow, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarOverflow, decorators: [{\r\n            type: Directive\r\n        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: ViewportControl, decorators: [{\r\n                    type: Host\r\n                }] }, { type: i0.ChangeDetectorRef }]; } });\n\n/**\r\n * remove component if no overflow on y axis\r\n */\r\nclass NgxCustomScrollbarOverflowYDirective extends NgxCustomScrollbarOverflow {\r\n    set ngxCustomScrollbarOverflowY(overflow) {\r\n        if (overflow === Overflow.NONE) {\r\n            this.viewportController.disableScroll(true);\r\n        }\r\n        this.overflow = overflow;\r\n    }\r\n    hasOverflow(viewportDimension) {\r\n        return viewportDimension.scrollHeight > viewportDimension.height;\r\n    }\r\n}\r\n/** @nocollapse */ NgxCustomScrollbarOverflowYDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarOverflowYDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });\r\n/** @nocollapse */ NgxCustomScrollbarOverflowYDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.6\", type: NgxCustomScrollbarOverflowYDirective, selector: \"[ngxCustomScrollbarOverflowY]\", inputs: { ngxCustomScrollbarOverflowY: \"ngxCustomScrollbarOverflowY\" }, usesInheritance: true, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarOverflowYDirective, decorators: [{\r\n            type: Directive,\r\n            args: [{ selector: \"[ngxCustomScrollbarOverflowY]\" }]\r\n        }], propDecorators: { ngxCustomScrollbarOverflowY: [{\r\n                type: Input\r\n            }] } });\n\n/**\r\n * renders component only if the viewport is overflows in x axis\r\n * otherwise remove / dont render it\r\n */\r\nclass NgxCustomScrollbarOverflowXDirective extends NgxCustomScrollbarOverflow {\r\n    set ngxCustomScrollbarOverflowX(overflow) {\r\n        this.overflow = overflow;\r\n    }\r\n    hasOverflow(viewportDimension) {\r\n        return viewportDimension.scrollWidth > viewportDimension.width;\r\n    }\r\n}\r\n/** @nocollapse */ NgxCustomScrollbarOverflowXDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarOverflowXDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });\r\n/** @nocollapse */ NgxCustomScrollbarOverflowXDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.6\", type: NgxCustomScrollbarOverflowXDirective, selector: \"[ngxCustomScrollbarOverflowX]\", inputs: { ngxCustomScrollbarOverflowX: \"ngxCustomScrollbarOverflowX\" }, usesInheritance: true, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarOverflowXDirective, decorators: [{\r\n            type: Directive,\r\n            args: [{ selector: \"[ngxCustomScrollbarOverflowX]\" }]\r\n        }], propDecorators: { ngxCustomScrollbarOverflowX: [{\r\n                type: Input\r\n            }] } });\n\nclass NgxCustomScrollbarModule {\r\n}\r\n/** @nocollapse */ NgxCustomScrollbarModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\n/** @nocollapse */ NgxCustomScrollbarModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarModule, declarations: [NgxCustomScrollbarComponent,\r\n        NgxCustomScrollbarHideOnNativeStyleDirective,\r\n        NgxCustomScrollbarOverflowXDirective,\r\n        NgxCustomScrollbarOverflowYDirective,\r\n        NgxCustomScrollbarScrollableDirective], imports: [CommonModule], exports: [NgxCustomScrollbarComponent,\r\n        NgxCustomScrollbarHideOnNativeStyleDirective,\r\n        NgxCustomScrollbarOverflowXDirective,\r\n        NgxCustomScrollbarOverflowYDirective,\r\n        NgxCustomScrollbarScrollableDirective] });\r\n/** @nocollapse */ NgxCustomScrollbarModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarModule, providers: [\r\n        ViewportControl\r\n    ], imports: [[\r\n            CommonModule,\r\n        ]] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    declarations: [\r\n                        NgxCustomScrollbarComponent,\r\n                        NgxCustomScrollbarHideOnNativeStyleDirective,\r\n                        NgxCustomScrollbarOverflowXDirective,\r\n                        NgxCustomScrollbarOverflowYDirective,\r\n                        NgxCustomScrollbarScrollableDirective,\r\n                    ],\r\n                    exports: [\r\n                        NgxCustomScrollbarComponent,\r\n                        NgxCustomScrollbarHideOnNativeStyleDirective,\r\n                        NgxCustomScrollbarOverflowXDirective,\r\n                        NgxCustomScrollbarOverflowYDirective,\r\n                        NgxCustomScrollbarScrollableDirective,\r\n                    ],\r\n                    imports: [\r\n                        CommonModule,\r\n                    ],\r\n                    providers: [\r\n                        ViewportControl\r\n                    ]\r\n                }]\r\n        }] });\n\n/*\r\n * Public API Surface of scrollbars\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { DomHelper, NgxCustomScrollbarComponent, NgxCustomScrollbarHideOnNativeStyleDirective, NgxCustomScrollbarModule, NgxCustomScrollbarOverflowXDirective, NgxCustomScrollbarOverflowYDirective, NgxCustomScrollbarScrollableDirective, Overflow, Viewport, ViewportControl, WindowResize };\n//# sourceMappingURL=ngx-customscrollbar.mjs.map\n","map":{"version":3,"file":"ngx-customscrollbar.mjs","sources":["../../../lib/ngx-customscrollbars/helper/dom.helper.ts","../../../lib/ngx-customscrollbars/helper/import-data.decorator.ts","../../../lib/ngx-customscrollbars/model/container-measure.model.ts","../../../lib/ngx-customscrollbars/provider/scroll.helper.ts","../../../lib/ngx-customscrollbars/provider/horiziontal-scroll.helper.ts","../../../lib/ngx-customscrollbars/provider/vertical-scroll.helper.ts","../../../lib/ngx-customscrollbars/model/scroll-container-measure.model.ts","../../../lib/ngx-customscrollbars/provider/window-resize.ts","../../../lib/ngx-customscrollbars/provider/viewport.control.ts","../../../lib/ngx-customscrollbars/components/scrollbar.component.ts","../../../lib/ngx-customscrollbars/components/scrollbar.component.html","../../../lib/ngx-customscrollbars/directives/no-native-style.directive.ts","../../../lib/ngx-customscrollbars/viewport/viewport.ts","../../../lib/ngx-customscrollbars/viewport/html.viewport.ts","../../../lib/ngx-customscrollbars/directives/scrollable-container.directive.ts","../../../lib/ngx-customscrollbars/model/overflow.ts","../../../lib/ngx-customscrollbars/directives/overflow-auto.ts","../../../lib/ngx-customscrollbars/directives/overflow-y.directive.ts","../../../lib/ngx-customscrollbars/directives/overflow-x.directive.ts","../../../lib/ngx-customscrollbars/custom-scrollbars.module.ts","../../../lib/public_api.ts","../../../lib/ngx-customscrollbar.ts"],"sourcesContent":["import { Scrollbar } from \"../api/scrollbar.interface\";\r\n\r\nexport namespace DomHelper {\r\n\r\n    export interface IElementMeasure {\r\n        innerHeight: number;\r\n        innerWidth: number;\r\n        height: number;\r\n        width: number;\r\n        top: number;\r\n        left: number;\r\n    }\r\n\r\n    export interface IScrollContainerMeasure extends IElementMeasure {\r\n        scrollHeight: number;\r\n        scrollLeft: number;\r\n        scrollTop: number;\r\n        scrollWidth: number;\r\n    }\r\n\r\n    /**\r\n     * get computed style from element\r\n     */\r\n    export function getElementStyle(el: HTMLElement, style: string): string | null {\r\n        let styleValue: string;\r\n        try {\r\n            styleValue = getComputedStyle(el, null).getPropertyValue(style);\r\n        } catch (e) {\r\n            styleValue = null;\r\n        }\r\n        return styleValue;\r\n    }\r\n\r\n    export function getMeasure(el: HTMLElement): DomHelper.IElementMeasure {\r\n        // get computed style not works that good and that fast like el.offsetHeight\r\n        return {\r\n            height: el.offsetHeight,\r\n            width: el.offsetWidth,\r\n            innerHeight: getInnerHeight(el),\r\n            innerWidth: getInnerWidth(el),\r\n            top: el.offsetTop,\r\n            left: el.offsetLeft\r\n        };\r\n    }\r\n\r\n    export function getScrollContainerMeasure(el: HTMLElement): DomHelper.IScrollContainerMeasure {\r\n        const elMeasure = getMeasure(el);\r\n        return {\r\n            ...elMeasure,\r\n            scrollHeight: el.scrollHeight,\r\n            scrollLeft: el.scrollLeft,\r\n            scrollTop: el.scrollTop,\r\n            scrollWidth: el.scrollWidth,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * get element inner height, without padding\r\n     */\r\n    export function getInnerHeight(el: HTMLElement): number {\r\n        /** @todo this will called alot times on resize */\r\n        const computed = getComputedStyle(el, null);\r\n        const paddingTop = parseInt(computed.getPropertyValue(\"padding-top\"), 10);\r\n        const paddingBot = parseInt(computed.getPropertyValue(\"padding-bottom\"), 10);\r\n        return el.offsetHeight - paddingTop - paddingBot;\r\n    }\r\n\r\n    /**\r\n     * get elment inner width without border, margin and padding\r\n     */\r\n    export function getInnerWidth(el: HTMLElement): number {\r\n        /** @todo this will called alot times on resize */\r\n        const computed = getComputedStyle(el, null);\r\n        const paddingLeft = parseInt(computed.getPropertyValue(\"padding-left\"), 10);\r\n        const paddingRight = parseInt(computed.getPropertyValue(\"padding-right\"), 10);\r\n        return el.offsetWidth - paddingLeft - paddingRight;\r\n    }\r\n\r\n    /**\r\n     * get element bounds\r\n     */\r\n    export function getElementBounds(el: HTMLElement): ClientRect {\r\n        return el.getBoundingClientRect();\r\n    }\r\n\r\n    /**\r\n     * calclulate offsetX / offsetY for MouseEvents\r\n     * we could use event.offsetX or event.offsetY but this is experimental\r\n     * and not working correctly in FF for some times.\r\n     */\r\n    export function getMouseOffset(event: MouseEvent): Scrollbar.IOffset {\r\n        const rect = (event.currentTarget as HTMLElement).getBoundingClientRect();\r\n        return {\r\n            left: event.clientX - rect.left,\r\n            top: event.clientY - rect.top\r\n        };\r\n    }\r\n}\r\n","\r\nexport function importData<T>(target, key = null, descriptor: PropertyDescriptor): PropertyDescriptor {\r\n\r\n    if (!descriptor) {\r\n        descriptor = Object.getOwnPropertyDescriptor(target, key);\r\n    }\r\n\r\n    const originalMethod = descriptor.value;\r\n    descriptor.value = function (data: T) {\r\n        // get all properties, exclude decorated property\r\n        Object.keys(data).forEach((property) => {\r\n            this[property] = data[property];\r\n        });\r\n        // call original descriptor\r\n        const result = originalMethod.call(this, data);\r\n        return result;\r\n    };\r\n    return descriptor;\r\n}\r\n","\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { importData } from \"../helper/import-data.decorator\";\r\n\r\n/**\r\n * viewport model so save / share current state from viewport\r\n */\r\nexport class ContainerMeasureModel<T> implements DomHelper.IElementMeasure {\r\n\r\n    private _measure: T;\r\n\r\n    private _innerHeight: number;\r\n\r\n    private _innerWidth: number;\r\n\r\n    private _height: number;\r\n\r\n    private _width: number;\r\n\r\n    private _top: number;\r\n\r\n    private _left: number;\r\n\r\n    public constructor(data: T) {\r\n        this.setMeasures(data);\r\n    }\r\n\r\n    @importData\r\n    public setMeasures(data: T) {\r\n        this._measure = data;\r\n    }\r\n\r\n    public get measures(): T {\r\n        return {...this._measure};\r\n    }\r\n\r\n    public set innerHeight(value: number) {\r\n        this._innerHeight = value;\r\n    }\r\n\r\n    public set innerWidth(value: number) {\r\n        this._innerWidth = value;\r\n    }\r\n\r\n    public set height(value: number) {\r\n        this._height = value;\r\n    }\r\n\r\n    public set width(value: number) {\r\n        this._width = value;\r\n    }\r\n\r\n    public set top(value: number) {\r\n        this._top = value;\r\n    }\r\n\r\n    public set left(value: number) {\r\n        this._left = value;\r\n    }\r\n\r\n    public get innerHeight(): number {\r\n        return this._innerHeight;\r\n    }\r\n\r\n    /**\r\n     * @returns number\r\n     */\r\n    public get innerWidth(): number {\r\n        return this._innerWidth;\r\n    }\r\n\r\n    public get height(): number {\r\n        return this._height;\r\n    }\r\n\r\n    public get width(): number {\r\n        return this._width;\r\n    }\r\n\r\n    public get top(): number {\r\n        return this._top;\r\n    }\r\n\r\n    public get left(): number {\r\n        return this._left;\r\n    }\r\n}\r\n","import { Scrollbar } from \"../api/scrollbar.interface\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\n\r\nexport abstract class ScrollHelper {\r\n\r\n    public constructor(\r\n        protected thumbMeasure: DomHelper.IElementMeasure,\r\n        protected trackMeasure: DomHelper.IElementMeasure,\r\n        protected _viewportMeasure: DomHelper.IScrollContainerMeasure\r\n    ) { }\r\n\r\n    public set viewportMeasure(measure: DomHelper.IScrollContainerMeasure) {\r\n        this._viewportMeasure = measure;\r\n    }\r\n\r\n    public get viewportMeasure(): DomHelper.IScrollContainerMeasure {\r\n        return this._viewportMeasure;\r\n    }\r\n\r\n    /**\r\n     * returns thumb transform property\r\n     */\r\n    public abstract getScrollThumbCssTransform(): any;\r\n\r\n    public abstract calculateDragDropScrollOffset(\r\n        dragMove: MouseEvent,\r\n        dragStart: Scrollbar.IOffset,\r\n        offset: ClientRect\r\n    ): Scrollbar.IOffset;\r\n\r\n    public abstract calculateScrollMax(): number;\r\n\r\n    public abstract calculateTrackMax(): number;\r\n\r\n    public abstract calculateThumbSize(): number;\r\n\r\n    public abstract calculateThumbPosition(): number;\r\n\r\n    public abstract getScrollThumbCssSize(): any;\r\n\r\n    public abstract isScrollable(): boolean;\r\n\r\n    /**\r\n     * return calculated page scroll offset for specific axis\r\n     */\r\n    public abstract calculatePageScroll(offset: Scrollbar.IOffset): Scrollbar.IOffset;\r\n\r\n    /**\r\n     * return true if we could skip scroll event otherwise false\r\n     */\r\n    public couldSkipScrollEvent(direction: Scrollbar.DIRECTION, event: Scrollbar.ScrollEvent): boolean {\r\n\r\n        if (direction === Scrollbar.DIRECTION.Y && event.scrolledY) {\r\n            return false;\r\n        }\r\n\r\n        if (direction === Scrollbar.DIRECTION.X && event.scrolledX) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n","import { ScrollHelper } from \"./scroll.helper\";\r\nimport { Scrollbar } from \"../api/scrollbar.interface\";\r\n\r\n/**\r\n * helper for calculations on vertical scrollbars\r\n */\r\nexport class HorizontalScrollHelper extends ScrollHelper {\r\n\r\n    public calculateScrollMax(): number {\r\n        return this.viewportMeasure.scrollWidth - this.viewportMeasure.width;\r\n    }\r\n\r\n    public calculateThumbPosition(): number {\r\n        const left = this.viewportMeasure.scrollLeft;\r\n        const offsetLeft = left * this.calculateTrackMax() / this.calculateScrollMax();\r\n        this.thumbMeasure.left = offsetLeft;\r\n        return offsetLeft;\r\n    }\r\n\r\n    public calculateDragDropScrollOffset(dragMove: MouseEvent, dragDroffset: Scrollbar.IOffset, offset: ClientRect) {\r\n        const offsetLeft = dragMove.clientX - offset.left;\r\n        const trackMax = this.calculateTrackMax();\r\n        const scrollMax = this.calculateScrollMax();\r\n\r\n        const top = this.viewportMeasure.scrollTop;\r\n        const left = scrollMax * (offsetLeft - dragDroffset.left) / trackMax;\r\n\r\n        return {top, left};\r\n    }\r\n\r\n    public calculateTrackMax(): number {\r\n        return this.trackMeasure.innerWidth - this.calculateThumbSize();\r\n    }\r\n\r\n    public calculateThumbSize(): number {\r\n        const thumbSize = this.viewportMeasure.width * this.trackMeasure.innerWidth / this.viewportMeasure.scrollWidth;\r\n        return thumbSize < 20 ? 20 : thumbSize;\r\n    }\r\n\r\n    /**\r\n     * returns thumb transform property\r\n     */\r\n    public getScrollThumbCssTransform(): any {\r\n        const left = this.calculateThumbPosition();\r\n\r\n        return {\r\n            style: \"transform\",\r\n            value: `translate3d(${left}px, 0, 0)`\r\n        };\r\n    }\r\n\r\n    public getScrollThumbCssSize() {\r\n        const width = this.calculateThumbSize();\r\n        return { style: \"width\", value: `${width}px` };\r\n    }\r\n\r\n    public isScrollable(): boolean {\r\n        return this.viewportMeasure.scrollWidth > this.viewportMeasure.width;\r\n    }\r\n\r\n    public calculatePageScroll(offset: Scrollbar.IOffset): Scrollbar.IOffset {\r\n\r\n        const modifier = offset.left < this.thumbMeasure.left\r\n            ? Scrollbar.PAGE_SCROLL.BACK\r\n            : Scrollbar.PAGE_SCROLL.FORWARD;\r\n\r\n        const scrollOffset = {\r\n            left: this.viewportMeasure.scrollLeft + (this.viewportMeasure.width * modifier),\r\n            top: this.viewportMeasure.scrollTop\r\n        };\r\n\r\n        return scrollOffset;\r\n    }\r\n}\r\n","import { ScrollHelper } from \"./scroll.helper\";\r\nimport { Scrollbar } from \"../api/scrollbar.interface\";\r\n\r\nexport class VerticalScrollHelper extends ScrollHelper {\r\n\r\n    /**\r\n     * calculate offset we have scrolled on viewport\r\n     */\r\n    public calculateDragDropScrollOffset(dragMove: MouseEvent, dragStartOffset: Scrollbar.IOffset, offset: ClientRect): Scrollbar.IOffset {\r\n\r\n        const offsetTop = dragMove.clientY - offset.top;\r\n        /** @TODO dont calculate this every time, this will not change on drag drop */\r\n        const trackMax = this.calculateTrackMax();\r\n        /** @TODO dont calculate this every time, this will not change on drag drop */\r\n        const scrollMax = this.calculateScrollMax();\r\n\r\n        const top = scrollMax * (offsetTop - dragStartOffset.top) / trackMax;\r\n        const left = this.viewportMeasure.scrollLeft;\r\n\r\n        return { top, left };\r\n    }\r\n\r\n    /**\r\n     * calculate max scroll position on viewport\r\n     */\r\n    public calculateScrollMax(): number {\r\n        return this.viewportMeasure.scrollHeight - this.viewportMeasure.height;\r\n    }\r\n\r\n    /**\r\n     * calculate max track position for scrollThumb\r\n     */\r\n    public calculateTrackMax(): number {\r\n        return this.trackMeasure.innerHeight - this.calculateThumbSize();\r\n    }\r\n\r\n    /**\r\n     * calculate thumbnail size\r\n     */\r\n    public calculateThumbSize(): number {\r\n        const thumbSize = this.viewportMeasure.height * this.trackMeasure.innerHeight / this.viewportMeasure.scrollHeight;\r\n        return thumbSize < 20 ? 20 : thumbSize;\r\n    }\r\n\r\n    /**\r\n     * calculate scrollthumb position, set position for thumb\r\n     */\r\n    public calculateThumbPosition(): number {\r\n        const top = this.viewportMeasure.scrollTop;\r\n        const valueTop = top * this.calculateTrackMax() / this.calculateScrollMax();\r\n        this.thumbMeasure.top = valueTop;\r\n        return valueTop;\r\n    }\r\n\r\n    /**\r\n     * returns thumb transform property\r\n     */\r\n    public getScrollThumbCssTransform(): any {\r\n        const top = this.calculateThumbPosition();\r\n        return {\r\n            style: \"transform\",\r\n            value: `translate3d(0, ${top}px, 0)`\r\n        };\r\n    }\r\n\r\n    public getScrollThumbCssSize(): any {\r\n        const height = this.calculateThumbSize();\r\n        return { style: \"height\", value: `${height}px` };\r\n    }\r\n\r\n    public isScrollable(): boolean {\r\n        return this.viewportMeasure.scrollHeight > this.viewportMeasure.height;\r\n    }\r\n\r\n    public calculatePageScroll(offset: Scrollbar.IOffset): Scrollbar.IOffset {\r\n\r\n        const modifier = offset.top < this.thumbMeasure.top\r\n            ? Scrollbar.PAGE_SCROLL.BACK\r\n            : Scrollbar.PAGE_SCROLL.FORWARD;\r\n\r\n        const scrollOffset = {\r\n            top: this.viewportMeasure.scrollTop + (this.viewportMeasure.height * modifier),\r\n            left: this.viewportMeasure.scrollLeft\r\n        };\r\n\r\n        return scrollOffset;\r\n    }\r\n}\r\n","import { ContainerMeasureModel } from \"./container-measure.model\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { importData } from \"../helper/import-data.decorator\";\r\n\r\nexport class ScrollContainerMeasureModel extends ContainerMeasureModel<DomHelper.IScrollContainerMeasure> {\r\n\r\n    /**\r\n     * available scroll height for viewport\r\n     */\r\n    private _scrollHeight: number;\r\n\r\n    /**\r\n     * scroll offset left\r\n     */\r\n    private _scrollLeft: number;\r\n\r\n    /**\r\n     * scroll offset top\r\n     */\r\n    private _scrollTop: number;\r\n\r\n    /**\r\n     * available scroll width for viewport\r\n     */\r\n    private _scrollWidth: number;\r\n\r\n    /**\r\n     * set measure data automatically imports data\r\n     * to model\r\n     */\r\n    @importData\r\n    public setMeasures(data: DomHelper.IScrollContainerMeasure) {\r\n        super.setMeasures(data);\r\n    }\r\n\r\n    public set scrollHeight(value: number) {\r\n        this._scrollHeight = value;\r\n    }\r\n\r\n    public set scrollLeft(value: number) {\r\n        this._scrollLeft = value;\r\n    }\r\n\r\n    public set scrollTop(value: number) {\r\n        this._scrollTop = value;\r\n    }\r\n\r\n    public set scrollWidth(value: number) {\r\n        this._scrollWidth = value;\r\n    }\r\n\r\n    public get scrollHeight(): number {\r\n        return this._scrollHeight;\r\n    }\r\n\r\n    public get scrollLeft(): number {\r\n        return this._scrollLeft;\r\n    }\r\n\r\n    public get scrollTop(): number {\r\n        return this._scrollTop;\r\n    }\r\n\r\n    public get scrollWidth(): number {\r\n        return this._scrollWidth;\r\n    }\r\n}\r\n","import { Injectable, NgZone } from \"@angular/core\";\r\nimport { Observable, Subject, fromEvent, Subscription, OperatorFunction } from \"rxjs\";\r\n\r\n/**\r\n *\r\n */\r\n@Injectable({ providedIn: \"root\" })\r\nexport class WindowResize {\r\n\r\n    /**\r\n     * window resize event stream\r\n     */\r\n    private windowResize$: Observable<Event>;\r\n\r\n    /**\r\n     * shared stream which one is registered on windowResize Stream\r\n     * all others will subscribe to shared stream so we can ensure\r\n     * only one window resize event exists\r\n     */\r\n    private shared$: Subject<any>;\r\n\r\n    /**\r\n     * current subscriber count on shared stream, the first subscriber\r\n     * will trigger shared stream registration on window resize stream\r\n     * if all subscribers are removed we automatically remove from\r\n     */\r\n    private subscriberCount = 0;\r\n\r\n    /**\r\n     * the subscription to window resize stream\r\n     * will be canceled if no one gets interrested anymore\r\n     */\r\n    private resizeSubscription: Subscription;\r\n\r\n    constructor(\r\n        private zone: NgZone\r\n    ) {\r\n        this.windowResize$ = fromEvent(window, \"resize\");\r\n        this.shared$ = new Subject();\r\n    }\r\n\r\n    /**\r\n     * create shared event stream and register to this\r\n     */\r\n    public onChange(): Observable<void> {\r\n        // subscribe\r\n        return Observable.create(observer => {\r\n            this.subscriberCount++;\r\n            const event$ = this.shared$.subscribe(observer);\r\n\r\n            if (this.subscriberCount === 1) {\r\n                this.subscribeToWindowResizeEvent();\r\n            }\r\n\r\n            // unsubscribe\r\n            return () => {\r\n                event$.unsubscribe();\r\n                this.subscriberCount--;\r\n                if (this.subscriberCount <= 0) {\r\n                    this.resizeSubscription.unsubscribe();\r\n                }\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * register to window resize events\r\n     */\r\n    private subscribeToWindowResizeEvent(): void {\r\n        this.zone.runOutsideAngular(() => {\r\n            this.resizeSubscription = this.windowResize$\r\n                .pipe(debounceAnimationFrame())\r\n                .subscribe(() => this.shared$.next());\r\n        });\r\n    }\r\n}\r\n\r\nfunction debounceAnimationFrame<T>(): OperatorFunction<T, T> {\r\n\r\n    return function (source$: Observable<T>): Observable<T> {\r\n\r\n        let resizeFired = false;\r\n        let drawing = false;\r\n\r\n        const requestAnimationFrame = window.requestAnimationFrame || (window as any).webkitRequestAnimationFrame;\r\n\r\n        const obs = new Observable<T>((observer) => {\r\n            function drawResize(): void {\r\n                if (resizeFired === true) {\r\n                    resizeFired = false;\r\n                    requestAnimationFrame(() => {\r\n                        observer.next();\r\n                        drawResize();\r\n                    });\r\n                } else {\r\n                    drawing = false;\r\n                }\r\n            }\r\n\r\n            source$.subscribe(() => {\r\n                if (drawing === false) {\r\n                    resizeFired = true;\r\n                    drawResize();\r\n                }\r\n            });\r\n        });\r\n        return obs;\r\n    };\r\n}\r\n","import { Injectable, OnDestroy } from \"@angular/core\";\r\nimport { Observable, ReplaySubject, Subject, Subscription } from \"rxjs\";\r\nimport { takeUntil } from \"rxjs/internal/operators/takeUntil\";\r\nimport { Scrollbar } from \"../api/scrollbar.interface\";\r\nimport { WindowResize } from \"./window-resize\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { ScrollContainerMeasureModel } from \"../model/scroll-container-measure.model\";\r\nimport { NgxCustomScrollbarComponent } from \"../components/scrollbar.component\";\r\n\r\n/**\r\n * viewport contol service, the glue between scrollbars and the viewport\r\n */\r\n@Injectable()\r\nexport class ViewportControl implements OnDestroy {\r\n\r\n    private viewportUpdate$: Subject<Scrollbar.Event>;\r\n\r\n    private viewportReady$: ReplaySubject<ScrollContainerMeasureModel>;\r\n\r\n    private viewportScroll$: Subject<Scrollbar.ScrollEvent>;\r\n\r\n    private destroy$: Subject<boolean> = new Subject();\r\n\r\n    private scrollSub: Subscription;\r\n\r\n    private scrollbars: Set<NgxCustomScrollbarComponent> = new Set();\r\n\r\n    private scrollbarViewPort: Scrollbar.IScrollbarViewport;\r\n    private scrollPosition = {\r\n        vertical: 0,\r\n        horizontal: 0\r\n    };\r\n\r\n    private viewportModel: ScrollContainerMeasureModel;\r\n\r\n    private _disabled: boolean;\r\n\r\n    public constructor(\r\n        private resize: WindowResize\r\n    ) {\r\n        this.viewportUpdate$ = new Subject();\r\n        this.viewportReady$ = new ReplaySubject(1);\r\n        this.viewportScroll$ = new Subject();\r\n\r\n        this.registerEvents();\r\n    }\r\n\r\n    /**\r\n     * inject the viewport which should be scrolled\r\n     */\r\n    public set viewPort(viewPort: Scrollbar.IScrollbarViewport) {\r\n\r\n        if (this.scrollbarViewPort && this.scrollbarViewPort === viewPort) {\r\n            return;\r\n        }\r\n\r\n        if (this.scrollSub) {\r\n            this.scrollSub.unsubscribe();\r\n        }\r\n\r\n        this.scrollbarViewPort = viewPort;\r\n        this.scrollSub = this.scrollbarViewPort.onScrolled()\r\n            .pipe(takeUntil(this.destroy$))\r\n            .subscribe(() => {\r\n                this.onScrolled();\r\n            });\r\n\r\n        this.scrollbarViewPort.control = this;\r\n\r\n        /** create new viewport model if a viewport has been bound */\r\n        this.viewportModel = new ScrollContainerMeasureModel(this.scrollbarViewPort.measureSize());\r\n        this.viewportReady$.next(this.viewportModel);\r\n\r\n        this.scrollbarViewPort.init();\r\n    }\r\n\r\n    /**\r\n     * register scrollbar to viewport so we could render them\r\n     * programatically if we need to do\r\n     */\r\n    public addScrollbar(scrollbar: NgxCustomScrollbarComponent) {\r\n        if (!this.scrollbars.has(scrollbar)) {\r\n            this.scrollbars.add(scrollbar);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * remove scrollbar to viewport\r\n     */\r\n    public removeScrollbar(scrollbar: NgxCustomScrollbarComponent) {\r\n        if (this.scrollbars.has(scrollbar)) {\r\n            this.scrollbars.delete(scrollbar);\r\n        }\r\n    }\r\n\r\n    public get viewportDimension(): DomHelper.IScrollContainerMeasure {\r\n        return this.viewportModel.measures;\r\n    }\r\n\r\n    public get disabled(): boolean {\r\n        return this._disabled || false;\r\n    }\r\n\r\n    /**\r\n     * scroll page by specific amount\r\n     * move this to helper\r\n     */\r\n    public scrollPage(direction: number) {\r\n        const pageSize = this.viewportDimension.height;\r\n        const scrollTop = this.viewportDimension.scrollTop + pageSize * direction;\r\n        this.scrollTo(this.sanitizeScrollPosition({ left: 0, top: scrollTop }));\r\n    }\r\n\r\n    /** not called if i just reload this */\r\n    ngOnDestroy(): void {\r\n        this.scrollbarViewPort.destroy();\r\n\r\n        this.destroy$.next(true);\r\n        this.viewportReady$.complete();\r\n        this.viewportUpdate$.complete();\r\n        this.destroy$.complete();\r\n        this.scrollbars.clear();\r\n        this.viewportModel = null;\r\n        this.scrollbars = null;\r\n    }\r\n\r\n    public onLoad(): Observable<ScrollContainerMeasureModel> {\r\n        return this.viewportReady$.asObservable();\r\n    }\r\n\r\n    public onScroll() {\r\n        return this.viewportScroll$.asObservable();\r\n    }\r\n\r\n    /**\r\n     * returns observable to get notified if viewport\r\n     * has been changed in scroll or has been refreshed\r\n     */\r\n    public onUpdate(): Observable<Scrollbar.Event | Scrollbar.ScrollEvent> {\r\n        return this.viewportUpdate$.asObservable();\r\n    }\r\n\r\n    /**\r\n     * viewport was changed, this could happen if new content, or window has been resized\r\n     * has been added or removed\r\n     */\r\n    public update() {\r\n        /** triggers soft update to trigger directives */\r\n        this.viewportModel.setMeasures(this.scrollbarViewPort.measureSize());\r\n        this.emitUpdate({ type: Scrollbar.VIEWPORT_EVENT.UPDATE });\r\n\r\n        /** get size again and trigger update for scrollbars */\r\n        this.viewportModel.setMeasures(this.scrollbarViewPort.measureSize());\r\n        this.scrollbars.forEach((scrollbar) => scrollbar.render());\r\n    }\r\n\r\n\r\n    /**\r\n     * viewport should scroll by specific amount\r\n     */\r\n    public scrollTo(scrolledTo) {\r\n        this.scrollbarViewPort.scrollTo(this.sanitizeScrollPosition(scrolledTo));\r\n    }\r\n\r\n    /**\r\n     * scroll viewport to origin\r\n     */\r\n    public reset() {\r\n        this.scrollTo({\r\n            top: 0,\r\n            left: 0\r\n        });\r\n    }\r\n\r\n    public disableScroll(disabled: boolean) {\r\n        this._disabled = disabled;\r\n    }\r\n\r\n    private registerEvents() {\r\n        this.resize.onChange()\r\n            .pipe(takeUntil(this.destroy$))\r\n            .subscribe(() => this.update());\r\n    }\r\n\r\n    /**\r\n     * viewport has been scrolled\r\n     */\r\n    private onScrolled() {\r\n\r\n        const scrolled = this.scrollbarViewPort.scrolledOffset;\r\n        const scrolledY = this.scrollPosition.vertical !== scrolled.top;\r\n        const scrolledX = this.scrollPosition.horizontal !== scrolled.left;\r\n\r\n        // update model to set current scroll offsets\r\n        this.viewportModel.scrollLeft = scrolled.left;\r\n        this.viewportModel.scrollTop = scrolled.top;\r\n\r\n        this.viewportScroll$.next({\r\n            scrolledY,\r\n            scrolledX,\r\n            type: Scrollbar.VIEWPORT_EVENT.SCROLLED\r\n        });\r\n\r\n        this.scrollPosition.vertical = scrolled.top;\r\n        this.scrollPosition.horizontal = scrolled.left;\r\n    }\r\n\r\n    /**\r\n     * emits an update event through viewportUpdate observable\r\n     */\r\n    private emitUpdate(event: Scrollbar.Event | Scrollbar.ScrollEvent) {\r\n        this.viewportUpdate$.next(event);\r\n    }\r\n\r\n    /**\r\n     * sanitize scroll position to ensure we not scroll over the bounds\r\n     */\r\n    private sanitizeScrollPosition(scrollTo: Scrollbar.IOffset) {\r\n        const scrollMaxY = this.viewportModel.scrollHeight - this.viewportModel.height;\r\n        const scrollMaxX = this.viewportModel.scrollWidth - this.viewportModel.width;\r\n        const { top, left } = scrollTo;\r\n\r\n        return {\r\n            top: top < 0 ? 0 : top > scrollMaxY ? scrollMaxY : top,\r\n            left: left < 0 ? 0 : left > scrollMaxX ? scrollMaxX : left,\r\n        };\r\n    }\r\n}\r\n","import {\r\n    AfterViewInit,\r\n    Component,\r\n    ElementRef,\r\n    Host,\r\n    Inject,\r\n    NgZone,\r\n    OnDestroy,\r\n    Renderer2,\r\n    ViewChild,\r\n    OnInit,\r\n    Input,\r\n    HostBinding,\r\n    Optional\r\n} from \"@angular/core\";\r\nimport { DOCUMENT } from \"@angular/common\";\r\nimport { fromEvent, Subject, Observable } from \"rxjs\";\r\nimport { tap, takeUntil, switchMap, finalize } from \"rxjs/operators\";\r\nimport { Scrollbar } from \"../api/scrollbar.interface\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { ContainerMeasureModel } from \"../model/container-measure.model\";\r\nimport { ScrollHelper } from \"../provider/scroll.helper\";\r\nimport { ViewportControl } from \"../provider/viewport.control\";\r\nimport { HorizontalScrollHelper } from \"../provider/horiziontal-scroll.helper\";\r\nimport { VerticalScrollHelper } from \"../provider/vertical-scroll.helper\";\r\n\r\n@Component({\r\n    selector: \"ngx-customscrollbar\",\r\n    templateUrl: \"scrollbar.component.html\",\r\n    styleUrls: [\"./scrollbar.component.scss\"]\r\n})\r\nexport class NgxCustomScrollbarComponent implements AfterViewInit, OnDestroy, OnInit {\r\n\r\n    @Input()\r\n    @HostBinding(\"class\")\r\n    @HostBinding(\"class.ngx-customscrollbars\")\r\n    public scrollDirection = Scrollbar.DIRECTION.Y;\r\n\r\n    @ViewChild(\"scrollbarTrack\", {read: ElementRef, static: true})\r\n    private scrollbarTrack: ElementRef;\r\n\r\n    @ViewChild(\"scrollbarThumb\", {read: ElementRef, static: true})\r\n    private scrollbarThumb: ElementRef;\r\n\r\n    private scrollHelper: ScrollHelper;\r\n    private isDestroyed$: Subject<boolean>;\r\n    private thumbMeasure: ContainerMeasureModel<DomHelper.IElementMeasure>;\r\n    private trackMeasure: ContainerMeasureModel<DomHelper.IElementMeasure>;\r\n    private viewportMeasure: DomHelper.IScrollContainerMeasure;\r\n\r\n    constructor(\r\n        @Host() @Optional() private viewportController: ViewportControl,\r\n        @Inject(DOCUMENT) private document,\r\n        private hostEl: ElementRef,\r\n        private ngZone: NgZone,\r\n        private renderer: Renderer2,\r\n    ) {\r\n        this.isDestroyed$ = new Subject();\r\n    }\r\n\r\n    /**\r\n     * initialize scrollbar track and scrollbar thumb events\r\n     */\r\n    ngOnInit() {\r\n\r\n        this.ngZone.runOutsideAngular(() => {\r\n            this.registerThumbEvents()\r\n                .pipe(takeUntil(this.isDestroyed$))\r\n                .subscribe();\r\n\r\n            this.registerScrollTrackEvents();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * dom is rendered and initialized\r\n     */\r\n    ngAfterViewInit() {\r\n\r\n        this.viewportController.addScrollbar(this);\r\n\r\n        /** viewport has been attached */\r\n        this.viewportController.onLoad()\r\n            .pipe(takeUntil(this.isDestroyed$))\r\n            .subscribe((measure) => this.handleViewportLoaded(measure));\r\n\r\n        /** viewport has been updated in size or is scrolled */\r\n        this.viewportController.onScroll()\r\n            .pipe(takeUntil(this.isDestroyed$))\r\n            .subscribe((event) => this.handleViewportScroll(event));\r\n    }\r\n\r\n    /**\r\n     * compoenent gets destroyed remove\r\n     * emit true to isDestroyed to remove subscriptions\r\n     * from all streams\r\n     */\r\n    ngOnDestroy() {\r\n\r\n        this.viewportController.removeScrollbar(this);\r\n\r\n        this.isDestroyed$.next(true);\r\n        this.isDestroyed$.complete();\r\n\r\n        this.scrollHelper = null;\r\n        this.thumbMeasure = null;\r\n        this.trackMeasure = null;\r\n        this.viewportMeasure = null;\r\n    }\r\n\r\n    public render() {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n        const track = this.scrollbarTrack.nativeElement;\r\n\r\n        this.renderer.setStyle(thumb, \"display\", \"none\");\r\n        this.trackMeasure.setMeasures(DomHelper.getMeasure(track));\r\n        this.thumbMeasure.setMeasures(DomHelper.getMeasure(thumb));\r\n\r\n        this.renderScrollbarThumb();\r\n        this.moveThumbToPosition();\r\n    }\r\n\r\n    /**\r\n     * a viewport has been added to viewport controller\r\n     */\r\n    private handleViewportLoaded(measure: DomHelper.IScrollContainerMeasure) {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n        const track = this.scrollbarTrack.nativeElement;\r\n        this.thumbMeasure = new ContainerMeasureModel(DomHelper.getMeasure(thumb));\r\n        this.trackMeasure = new ContainerMeasureModel(DomHelper.getMeasure(track));\r\n        this.viewportMeasure = measure;\r\n\r\n        this.initializeScrollHelper();\r\n        this.renderScrollbarThumb();\r\n        this.moveThumbToPosition();\r\n    }\r\n\r\n    /**\r\n     * viewportControl sends update, this could be\r\n     * initialized, scrolled or content changes\r\n     */\r\n    private handleViewportScroll(event: Scrollbar.ScrollEvent) {\r\n\r\n        if (this.scrollHelper.couldSkipScrollEvent(this.scrollDirection, event)) {\r\n            return;\r\n        }\r\n\r\n        this.renderScrollbarThumb();\r\n        this.moveThumbToPosition();\r\n    }\r\n\r\n    /**\r\n     * initialize scroll helpers\r\n     */\r\n    private initializeScrollHelper() {\r\n\r\n        if (!this.scrollHelper) {\r\n            const scrollHelperConstructor = this.scrollDirection === Scrollbar.DIRECTION.X\r\n                ? HorizontalScrollHelper\r\n                : VerticalScrollHelper;\r\n\r\n            this.scrollHelper = new scrollHelperConstructor(this.thumbMeasure, this.trackMeasure, this.viewportMeasure);\r\n        } else {\r\n            this.scrollHelper.viewportMeasure = this.viewportMeasure;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * renders scrollbar thumb\r\n     */\r\n    private renderScrollbarThumb() {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n\r\n        if (!this.scrollHelper.isScrollable()) {\r\n            this.renderer.setStyle(thumb, \"display\", \"none\");\r\n        } else {\r\n            const cssSize = this.scrollHelper.getScrollThumbCssSize();\r\n            this.renderer.removeStyle(thumb, \"display\");\r\n            this.renderer.setStyle(thumb, cssSize.style, cssSize.value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * move thumb to position after viewport has been scrolled\r\n     */\r\n    private moveThumbToPosition() {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n        const scrollCSS = this.scrollHelper.getScrollThumbCssTransform();\r\n        this.renderer.setStyle(thumb, scrollCSS.style, scrollCSS.value);\r\n    }\r\n\r\n    /**\r\n     * register scrollbar track click event to scroll a page\r\n     */\r\n    private registerScrollTrackEvents() {\r\n        const track = this.scrollbarTrack.nativeElement;\r\n        fromEvent(track, \"click\")\r\n            .pipe(takeUntil(this.isDestroyed$))\r\n            .subscribe((event: MouseEvent) => {\r\n                if (event.target === this.scrollbarThumb.nativeElement) {\r\n                    return false;\r\n                }\r\n                const offset = this.scrollHelper.calculatePageScroll(DomHelper.getMouseOffset(event));\r\n                this.viewportController.scrollTo(offset);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * handle drag drop on scrollbar thumb\r\n     */\r\n    private registerThumbEvents(): Observable<MouseEvent> {\r\n        const mouseDown$ = fromEvent(this.scrollbarThumb.nativeElement, \"mousedown\");\r\n        const mouseMove$ = fromEvent(this.document, \"mousemove\");\r\n        const mouseUp$ = fromEvent(window, \"mouseup\");\r\n\r\n        const dragDrop$ = mouseDown$.pipe(\r\n            tap(() => this.document.onselectstart = () => false),\r\n            switchMap((dragStart: MouseEvent) => {\r\n                const offset = DomHelper.getElementBounds(this.scrollbarTrack.nativeElement);\r\n                const dragOffset = DomHelper.getMouseOffset(dragStart);\r\n\r\n                this.renderer.addClass(this.hostEl.nativeElement, \"dragged\");\r\n\r\n                /** switch to mousemove stream until we press mouse button */\r\n                return mouseMove$.pipe(\r\n                    tap((dragMove: MouseEvent) => {\r\n                        this.viewportController.scrollTo(\r\n                            this.scrollHelper.calculateDragDropScrollOffset(dragMove, dragOffset, offset)\r\n                        );\r\n                    }),\r\n                    finalize(() => {\r\n                        this.document.onselectstart = null;\r\n                        this.renderer.removeClass(this.hostEl.nativeElement, \"dragged\");\r\n                    }),\r\n                    takeUntil(mouseUp$),\r\n                );\r\n            })\r\n        );\r\n        return dragDrop$.pipe(takeUntil(this.isDestroyed$));\r\n    }\r\n}\r\n","<div class=\"scrollbar-up\" #scrollbarTopLeft></div>\r\n<div class=\"scrollbar-track\" #scrollbarTrack>\r\n    <div class=\"scrollbar-thumb\" #scrollbarThumb></div>\r\n</div>\r\n<div class=\"scrollbar-up\" #scrollbarRightBottom></div>\r\n","import { Directive, ViewContainerRef, TemplateRef, Input } from \"@angular/core\";\r\nimport { Platform } from \"@angular/cdk/platform\";\r\n\r\n/**\r\n * dont show element if we can support styles of scrollbar\r\n * only via css. Possible with webkit / BLINK (chrome, chromium, opera)\r\n */\r\n@Directive({ selector: \"[ngxCustomScrollbarHideOnNativeStyle]\"})\r\nexport class NgxCustomScrollbarHideOnNativeStyleDirective {\r\n\r\n    constructor(\r\n        /** The view container to add items to. */\r\n        private viewContainerRef: ViewContainerRef,\r\n        /** The template to use when stamping out new items. */\r\n        private template: TemplateRef<any>,\r\n        /** platform */\r\n        private platform: Platform\r\n    ) { }\r\n\r\n    @Input()\r\n    set q2gScrollbarHideOnNativeStyle(hideOnNative: boolean) {\r\n        if (!this.platform.WEBKIT && !this.platform.BLINK || hideOnNative === false) {\r\n            this.viewContainerRef.createEmbeddedView(this.template);\r\n        } else {\r\n            this.viewContainerRef.clear();\r\n        }\r\n    }\r\n}\r\n","import { Scrollbar } from \"../api/scrollbar.interface\";\r\nimport { Subject } from \"rxjs\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { IViewportControl } from \"../api/viewport-control.interface\";\r\n\r\nexport abstract class Viewport implements Scrollbar.IScrollbarViewport {\r\n\r\n    protected viewportScrolledOffset = { top: 0, left: 0 };\r\n\r\n    protected scrolled$: Subject<void> = new Subject();\r\n\r\n    protected viewPortController: IViewportControl;\r\n\r\n    abstract measureSize(): DomHelper.IScrollContainerMeasure;\r\n\r\n    abstract get scrolledOffset();\r\n\r\n    abstract scrollTo(offset: Scrollbar.IOffset);\r\n\r\n    public destroy() { /* noop */ }\r\n\r\n    public init() { /** noop */ }\r\n\r\n    public set control(control: IViewportControl) {\r\n        this.viewPortController = control;\r\n    }\r\n\r\n    public get control(): IViewportControl {\r\n        return this.viewPortController;\r\n    }\r\n\r\n    public reset() {\r\n        this.scrollTo({top: 0, left: 0});\r\n    }\r\n\r\n    public onScrolled() {\r\n        return this.scrolled$.asObservable();\r\n    }\r\n}\r\n","import { NgZone } from \"@angular/core\";\r\nimport { supportsScrollBehavior } from \"@angular/cdk/platform\";\r\nimport { fromEvent, Observable, Subject } from \"rxjs\";\r\nimport { takeUntil } from \"rxjs/operators\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { Viewport } from \"./viewport\";\r\nimport { Scrollbar } from \"../api/scrollbar.interface\";\r\n\r\nexport class HtmlViewport extends Viewport {\r\n\r\n    /**\r\n     * stream to register on native scroll events\r\n     */\r\n    private scroll$: Observable<Event>;\r\n\r\n    private destroy$: Subject<boolean>;\r\n\r\n    private isDestroyed = false;\r\n\r\n    public constructor(\r\n        private zone: NgZone,\r\n        private element: HTMLElement\r\n    ) {\r\n        super();\r\n        this.destroy$ = new Subject();\r\n    }\r\n\r\n    /** element is bound to viewport */\r\n    public init() {\r\n\r\n        this.scroll$ = fromEvent(this.element, \"scroll\")\r\n            .pipe(takeUntil(this.destroy$));\r\n\r\n        this.registerEvents();\r\n    }\r\n\r\n    public destroy() {\r\n\r\n        /**\r\n         * component gets allready destroyed\r\n         * could happens twice if we create this with directive which destroys the viewport\r\n         * or we destroy the whole component which provides viewport control\r\n         */\r\n        if (this.isDestroyed) {\r\n            return;\r\n        }\r\n\r\n        this.destroy$.next(true);\r\n        this.destroy$.complete();\r\n        this.isDestroyed = true;\r\n    }\r\n\r\n    /**\r\n     * get container dimensions\r\n     */\r\n    public measureSize(): DomHelper.IScrollContainerMeasure {\r\n        return DomHelper.getScrollContainerMeasure(this.element);\r\n    }\r\n\r\n    /**\r\n     * scroll viewport to specific position\r\n     */\r\n    public scrollTo(offset: Scrollbar.IOffset) {\r\n        if (supportsScrollBehavior()) {\r\n            this.element.scrollTo(offset);\r\n        } else {\r\n            const { top, left } = offset;\r\n            if (left || left === 0) {\r\n                this.element.scrollLeft = left;\r\n            }\r\n            if (top || top === 0) {\r\n                this.element.scrollTop = top;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get scrolled offset\r\n     */\r\n    public get scrolledOffset() {\r\n        return {\r\n            top: this.element.scrollTop,\r\n            left: this.element.scrollLeft\r\n        };\r\n    }\r\n\r\n    /**\r\n     * register to scroll event on html node\r\n     */\r\n    private registerEvents() {\r\n        this.zone.runOutsideAngular(() => {\r\n            this.scroll$.subscribe(() => {\r\n                if (!this.viewPortController.disabled) {\r\n                    this.scrolled$.next();\r\n                    return;\r\n                }\r\n                this.scrollTo({ left: 0, top: 0 });\r\n            });\r\n        });\r\n    }\r\n}\r\n","import { Directive, NgZone, Host, ElementRef, OnDestroy, OnInit, AfterViewChecked, AfterViewInit, Input, Renderer2 } from \"@angular/core\";\r\nimport { ViewportControl } from \"../provider/viewport.control\";\r\nimport { HtmlViewport } from \"../viewport/html.viewport\";\r\nimport { Subject, fromEvent } from \"rxjs\";\r\nimport { filter, takeUntil, delay, distinctUntilChanged } from \"rxjs/operators\";\r\n\r\ninterface ContainerScrollSize {\r\n    scrollHeight: number;\r\n    scrollWidth: number;\r\n}\r\n\r\nenum CHANGE_DETECTION_STRATEGY {\r\n    CHECKED  = \"checked\", // change detection\r\n    INPUT    = \"input\",\r\n    MUTATION = \"mutation\"\r\n}\r\n\r\n/**\r\n * directive for html elements\r\n * this will wrap the html element into HtmlViewport\r\n */\r\n@Directive({\r\n    selector: \"[ngxCustomScrollbarScrollable]\",\r\n    exportAs: \"ngxCustomScrollbarHTMLViewport\"\r\n})\r\nexport class NgxCustomScrollbarScrollableDirective implements AfterViewInit, AfterViewChecked, OnDestroy, OnInit {\r\n\r\n    private htmlViewport: HtmlViewport;\r\n\r\n    private scrollSize: ContainerScrollSize;\r\n\r\n    private update$: Subject<ContainerScrollSize> = new Subject();\r\n\r\n    private changeDetection: CHANGE_DETECTION_STRATEGY = CHANGE_DETECTION_STRATEGY.CHECKED;\r\n\r\n    private destroyed$: Subject<boolean> = new Subject();\r\n\r\n    private oldScrollDimension = null;\r\n\r\n    constructor(\r\n        @Host() private viewportControl: ViewportControl,\r\n        private zone: NgZone,\r\n        private el: ElementRef,\r\n        private renderer: Renderer2\r\n    ) {}\r\n\r\n    @Input(\"ngxCustomScrollbarScrollable\")\r\n    public set changeDetectionStrategy(strategy: CHANGE_DETECTION_STRATEGY) {\r\n        if (strategy) {\r\n            this.changeDetection = strategy;\r\n        }\r\n    }\r\n\r\n    ngOnInit() {\r\n        this.renderer.addClass(this.el.nativeElement, \"ngx-customscrollbar--html-viewport\");\r\n        this.update$.pipe(\r\n            distinctUntilChanged(),\r\n            delay(100),\r\n            filter((newSize) => {\r\n                const hasChanged = JSON.stringify(newSize) !== JSON.stringify(this.scrollSize);\r\n                this.scrollSize = newSize;\r\n                return hasChanged;\r\n            }),\r\n            takeUntil(this.destroyed$)\r\n        ).subscribe({\r\n            next: () => this.viewportControl.update()\r\n        });\r\n\r\n        switch (this.changeDetection) {\r\n            case CHANGE_DETECTION_STRATEGY.INPUT:\r\n                this.initInputChangeDetection();\r\n                break;\r\n        }\r\n    }\r\n\r\n    ngAfterViewChecked() {\r\n        if (this.changeDetection === CHANGE_DETECTION_STRATEGY.CHECKED) {\r\n            const newScrollDimension = this.getScrollDimension();\r\n            if (this.oldScrollDimension && JSON.stringify(this.oldScrollDimension) === JSON.stringify(newScrollDimension)) {\r\n                return;\r\n            }\r\n            this.oldScrollDimension = newScrollDimension;\r\n            this.update$.next(newScrollDimension);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * if component gets destroyed tell our control we gets destroyed\r\n     * and remove from dom mutations\r\n     *\r\n     * @memberof ScrollableContainerDirective\r\n     */\r\n    ngOnDestroy() {\r\n        this.htmlViewport.destroy();\r\n        this.viewportControl = null;\r\n        this.update$.complete();\r\n        this.update$ = null;\r\n\r\n        this.destroyed$.next(true);\r\n        this.destroyed$.complete();\r\n        this.destroyed$ = null;\r\n    }\r\n\r\n    /**\r\n     * start watching the dom after view has been initialized\r\n     * this ensures initial data has allready been set.\r\n     *\r\n     * We only want to know if we add or remove some items\r\n     *\r\n     * @memberof ScrollableContainerDirective\r\n     */\r\n    ngAfterViewInit(): void {\r\n        this.scrollSize   = this.getScrollDimension();\r\n        this.htmlViewport = new HtmlViewport(this.zone, this.el.nativeElement);\r\n        this.viewportControl.viewPort = this.htmlViewport;\r\n    }\r\n\r\n    /**\r\n     * get scroll dimensions\r\n     */\r\n    private getScrollDimension(): ContainerScrollSize {\r\n        return {\r\n            scrollHeight: this.el.nativeElement.scrollHeight,\r\n            scrollWidth: this.el.nativeElement.scrollWidth\r\n        };\r\n    }\r\n\r\n    private initInputChangeDetection() {\r\n        fromEvent(this.el.nativeElement, \"input\")\r\n            .pipe(takeUntil(this.destroyed$))\r\n            .subscribe({\r\n                next: () => this.update$.next(this.getScrollDimension())\r\n            });\r\n    }\r\n}\r\n","export class Overflow {\r\n    public static readonly NONE   = \"none\";\r\n    public static readonly AUTO   = \"auto\";\r\n    public static readonly SCROLL = \"scroll\";\r\n}\r\n","import { ViewContainerRef, TemplateRef, Host, DoCheck, OnInit, OnDestroy, ChangeDetectorRef, Directive } from \"@angular/core\";\r\nimport { switchMap, tap, takeUntil } from \"rxjs/operators\";\r\nimport { Subject } from \"rxjs\";\r\nimport { Scrollbar } from \"../api/scrollbar.interface\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { Overflow } from \"../model/overflow\";\r\nimport { ViewportControl } from \"../provider/viewport.control\";\r\n\r\n/**\r\n * remove component if we dont need to scroll anymore, and\r\n * show it again if we can scroll. Same as css overflow: auto\r\n */\r\n@Directive()\nexport abstract class NgxCustomScrollbarOverflow implements DoCheck, OnDestroy, OnInit {\r\n\r\n    protected overflow: Overflow = Overflow.SCROLL;\r\n\r\n    private isViewportVisible = false;\r\n    private needsUpdate: boolean;\r\n    private destroyed$: Subject<boolean>;\r\n\r\n    constructor(\r\n        /** The view container to add items to. */\r\n        private viewContainerRef: ViewContainerRef,\r\n\r\n        /** The template to use when stamping out new items. */\r\n        private template: TemplateRef<any>,\r\n        /** viewport control to bound */\r\n\r\n        @Host() protected viewportController: ViewportControl,\r\n        private changeDetector: ChangeDetectorRef\r\n    ) {\r\n        this.needsUpdate = false;\r\n        this.destroyed$ = new Subject();\r\n    }\r\n\r\n    /**\r\n     * angular change detection hook\r\n     */\r\n    ngDoCheck() {\r\n        if (this.needsUpdate) {\r\n            this.toggleScrollbar();\r\n        }\r\n        this.needsUpdate = false;\r\n    }\r\n\r\n    /**\r\n     * scrollbar gets destroyed\r\n     */\r\n    ngOnDestroy() {\r\n        this.destroyed$.next(true);\r\n    }\r\n\r\n    /**\r\n     * register on viewportControl onUpdate event\r\n     * and check scrollbar for visibility\r\n     */\r\n    ngOnInit() {\r\n        this.viewportController.onLoad().pipe(\r\n            tap(() => this.checkScrollbarNeedsUpdate()),\r\n            switchMap(() => this.viewportController.onUpdate()),\r\n            takeUntil(this.destroyed$)\r\n        ).subscribe((updateEvent) => {\r\n            const event = updateEvent.type;\r\n            const checkUpdate = event === Scrollbar.VIEWPORT_EVENT.UPDATE;\r\n\r\n            if (checkUpdate) {\r\n                this.checkScrollbarNeedsUpdate();\r\n            }\r\n        });\r\n    }\r\n\r\n    protected abstract hasOverflow(dimensions: DomHelper.IScrollContainerMeasure): boolean;\r\n\r\n    /**\r\n     * check for updates on scrollbar\r\n     */\r\n    protected checkScrollbarNeedsUpdate() {\r\n\r\n        let isOverflow: boolean;\r\n\r\n        switch (this.overflow) {\r\n            case Overflow.NONE: isOverflow = false; break;\r\n            case Overflow.SCROLL: isOverflow = true; break;\r\n            default: isOverflow = this.hasOverflow(this.viewportController.viewportDimension);\r\n        }\r\n\r\n        this.needsUpdate = isOverflow !== this.isViewportVisible;\r\n        this.isViewportVisible = isOverflow;\r\n\r\n        if (this.needsUpdate) {\r\n            this.changeDetector.detectChanges();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * toggle scrollbar visibility, clears viewport\r\n     * if scrollbar should be hidden now\r\n     */\r\n    private toggleScrollbar() {\r\n        if (this.isViewportVisible) {\r\n            this.viewContainerRef.createEmbeddedView(this.template);\r\n        } else {\r\n            this.viewContainerRef.clear();\r\n        }\r\n    }\r\n}\r\n","import { Directive, Input} from \"@angular/core\";\r\nimport { NgxCustomScrollbarOverflow } from \"./overflow-auto\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { Overflow } from \"../model/overflow\";\r\n\r\n/**\r\n * remove component if no overflow on y axis\r\n */\r\n@Directive({selector: \"[ngxCustomScrollbarOverflowY]\"})\r\nexport class NgxCustomScrollbarOverflowYDirective extends NgxCustomScrollbarOverflow {\r\n\r\n    @Input()\r\n    public set ngxCustomScrollbarOverflowY(overflow: \"none\" | \"auto\" | \"scroll\") {\r\n        if (overflow === Overflow.NONE) {\r\n            this.viewportController.disableScroll(true);\r\n        }\r\n        this.overflow = overflow;\r\n    }\r\n\r\n    protected hasOverflow(viewportDimension: DomHelper.IScrollContainerMeasure): boolean {\r\n        return viewportDimension.scrollHeight > viewportDimension.height;\r\n    }\r\n}\r\n","\r\nimport { Directive, Input} from \"@angular/core\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { Overflow } from \"../model/overflow\";\r\nimport { NgxCustomScrollbarOverflow } from \"./overflow-auto\";\r\n\r\n/**\r\n * renders component only if the viewport is overflows in x axis\r\n * otherwise remove / dont render it\r\n */\r\n@Directive({ selector: \"[ngxCustomScrollbarOverflowX]\" })\r\nexport class NgxCustomScrollbarOverflowXDirective extends NgxCustomScrollbarOverflow {\r\n\r\n    @Input()\r\n    public set ngxCustomScrollbarOverflowX(overflow: Overflow) {\r\n        this.overflow = overflow;\r\n    }\r\n\r\n    protected hasOverflow(viewportDimension: DomHelper.IScrollContainerMeasure): boolean {\r\n        return viewportDimension.scrollWidth > viewportDimension.width;\r\n    }\r\n}\r\n","import { NgModule } from \"@angular/core\";\r\nimport { CommonModule } from \"@angular/common\";\r\nimport { NgxCustomScrollbarComponent} from \"./components/scrollbar.component\";\r\nimport { NgxCustomScrollbarHideOnNativeStyleDirective } from \"./directives/no-native-style.directive\";\r\nimport { NgxCustomScrollbarScrollableDirective } from \"./directives/scrollable-container.directive\";\r\nimport { NgxCustomScrollbarOverflowYDirective } from \"./directives/overflow-y.directive\";\r\nimport { NgxCustomScrollbarOverflowXDirective } from \"./directives/overflow-x.directive\";\r\nimport { ViewportControl } from \"./provider/viewport.control\";\r\n\r\n@NgModule({\r\n    declarations: [\r\n        NgxCustomScrollbarComponent,\r\n        NgxCustomScrollbarHideOnNativeStyleDirective,\r\n        NgxCustomScrollbarOverflowXDirective,\r\n        NgxCustomScrollbarOverflowYDirective,\r\n        NgxCustomScrollbarScrollableDirective,\r\n    ],\r\n    exports: [\r\n        NgxCustomScrollbarComponent,\r\n        NgxCustomScrollbarHideOnNativeStyleDirective,\r\n        NgxCustomScrollbarOverflowXDirective,\r\n        NgxCustomScrollbarOverflowYDirective,\r\n        NgxCustomScrollbarScrollableDirective,\r\n    ],\r\n    imports: [\r\n        CommonModule,\r\n    ],\r\n    providers: [\r\n        ViewportControl\r\n    ]\r\n})\r\nexport class NgxCustomScrollbarModule { }\r\n","/*\r\n * Public API Surface of scrollbars\r\n */\r\nexport * from \"./ngx-customscrollbars/custom-scrollbars.module\";\r\nexport * from \"./ngx-customscrollbars/helper/dom.helper\";\r\nexport * from \"./ngx-customscrollbars/model/overflow\";\r\nexport * from \"./ngx-customscrollbars/provider/viewport.control\";\r\nexport * from \"./ngx-customscrollbars/provider/window-resize\";\r\nexport * from \"./ngx-customscrollbars/viewport/viewport\";\r\nexport * from \"./ngx-customscrollbars/directives/scrollable-container.directive\"\r\nexport * from \"./ngx-customscrollbars/directives/overflow-x.directive\"\r\nexport * from \"./ngx-customscrollbars/directives/overflow-y.directive\"\r\nexport * from \"./ngx-customscrollbars/directives/no-native-style.directive\"\r\nexport * from \"./ngx-customscrollbars/components/scrollbar.component\"","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":["i1.WindowResize","takeUntil","i1.ViewportControl"],"mappings":";;;;;;;;;;AAEM,IAAW,UA+FhB;AA/FD,CAAA,UAAiB,SAAS,EAAA;AAkBtB;;AAEG;AACH,IAAA,SAAgB,eAAe,CAAC,EAAe,EAAE,KAAa,EAAA;AAC1D,QAAA,IAAI,UAAkB,CAAC;QACvB,IAAI;AACA,YAAA,UAAU,GAAG,gBAAgB,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;AACnE,SAAA;AAAC,QAAA,OAAO,CAAC,EAAE;YACR,UAAU,GAAG,IAAI,CAAC;AACrB,SAAA;AACD,QAAA,OAAO,UAAU,CAAC;KACrB;AARe,IAAA,SAAA,CAAA,eAAe,kBAQ9B,CAAA;IAED,SAAgB,UAAU,CAAC,EAAe,EAAA;;QAEtC,OAAO;YACH,MAAM,EAAE,EAAE,CAAC,YAAY;YACvB,KAAK,EAAE,EAAE,CAAC,WAAW;AACrB,YAAA,WAAW,EAAE,cAAc,CAAC,EAAE,CAAC;AAC/B,YAAA,UAAU,EAAE,aAAa,CAAC,EAAE,CAAC;YAC7B,GAAG,EAAE,EAAE,CAAC,SAAS;YACjB,IAAI,EAAE,EAAE,CAAC,UAAU;SACtB,CAAC;KACL;AAVe,IAAA,SAAA,CAAA,UAAU,aAUzB,CAAA;IAED,SAAgB,yBAAyB,CAAC,EAAe,EAAA;AACrD,QAAA,MAAM,SAAS,GAAG,UAAU,CAAC,EAAE,CAAC,CAAC;QACjC,OAAO;AACH,YAAA,GAAG,SAAS;YACZ,YAAY,EAAE,EAAE,CAAC,YAAY;YAC7B,UAAU,EAAE,EAAE,CAAC,UAAU;YACzB,SAAS,EAAE,EAAE,CAAC,SAAS;YACvB,WAAW,EAAE,EAAE,CAAC,WAAW;SAC9B,CAAC;KACL;AATe,IAAA,SAAA,CAAA,yBAAyB,4BASxC,CAAA;AAED;;AAEG;IACH,SAAgB,cAAc,CAAC,EAAe,EAAA;;QAE1C,MAAM,QAAQ,GAAG,gBAAgB,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;AAC5C,QAAA,MAAM,UAAU,GAAG,QAAQ,CAAC,QAAQ,CAAC,gBAAgB,CAAC,aAAa,CAAC,EAAE,EAAE,CAAC,CAAC;AAC1E,QAAA,MAAM,UAAU,GAAG,QAAQ,CAAC,QAAQ,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC;AAC7E,QAAA,OAAO,EAAE,CAAC,YAAY,GAAG,UAAU,GAAG,UAAU,CAAC;KACpD;AANe,IAAA,SAAA,CAAA,cAAc,iBAM7B,CAAA;AAED;;AAEG;IACH,SAAgB,aAAa,CAAC,EAAe,EAAA;;QAEzC,MAAM,QAAQ,GAAG,gBAAgB,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;AAC5C,QAAA,MAAM,WAAW,GAAG,QAAQ,CAAC,QAAQ,CAAC,gBAAgB,CAAC,cAAc,CAAC,EAAE,EAAE,CAAC,CAAC;AAC5E,QAAA,MAAM,YAAY,GAAG,QAAQ,CAAC,QAAQ,CAAC,gBAAgB,CAAC,eAAe,CAAC,EAAE,EAAE,CAAC,CAAC;AAC9E,QAAA,OAAO,EAAE,CAAC,WAAW,GAAG,WAAW,GAAG,YAAY,CAAC;KACtD;AANe,IAAA,SAAA,CAAA,aAAa,gBAM5B,CAAA;AAED;;AAEG;IACH,SAAgB,gBAAgB,CAAC,EAAe,EAAA;AAC5C,QAAA,OAAO,EAAE,CAAC,qBAAqB,EAAE,CAAC;KACrC;AAFe,IAAA,SAAA,CAAA,gBAAgB,mBAE/B,CAAA;AAED;;;;AAIG;IACH,SAAgB,cAAc,CAAC,KAAiB,EAAA;QAC5C,MAAM,IAAI,GAAI,KAAK,CAAC,aAA6B,CAAC,qBAAqB,EAAE,CAAC;QAC1E,OAAO;AACH,YAAA,IAAI,EAAE,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,IAAI;AAC/B,YAAA,GAAG,EAAE,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,GAAG;SAChC,CAAC;KACL;AANe,IAAA,SAAA,CAAA,cAAc,iBAM7B,CAAA;AACL,CAAC,EA/FgB,SAAS,KAAT,SAAS,GA+FzB,EAAA,CAAA,CAAA;;AChGK,SAAU,UAAU,CAAI,MAAM,EAAE,GAAG,GAAG,IAAI,EAAE,UAA8B,EAAA;IAE5E,IAAI,CAAC,UAAU,EAAE;QACb,UAAU,GAAG,MAAM,CAAC,wBAAwB,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;AAC7D,KAAA;AAED,IAAA,MAAM,cAAc,GAAG,UAAU,CAAC,KAAK,CAAC;AACxC,IAAA,UAAU,CAAC,KAAK,GAAG,UAAU,IAAO,EAAA;;QAEhC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,QAAQ,KAAI;YACnC,IAAI,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC;AACpC,SAAC,CAAC,CAAC;;QAEH,MAAM,MAAM,GAAG,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC/C,QAAA,OAAO,MAAM,CAAC;AAClB,KAAC,CAAC;AACF,IAAA,OAAO,UAAU,CAAC;AACtB;;ACdA;;AAEG;MACU,qBAAqB,CAAA;AAgB9B,IAAA,WAAA,CAAmB,IAAO,EAAA;AACtB,QAAA,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;KAC1B;AAGM,IAAA,WAAW,CAAC,IAAO,EAAA;AACtB,QAAA,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;KACxB;AAED,IAAA,IAAW,QAAQ,GAAA;AACf,QAAA,OAAO,EAAC,GAAG,IAAI,CAAC,QAAQ,EAAC,CAAC;KAC7B;IAED,IAAW,WAAW,CAAC,KAAa,EAAA;AAChC,QAAA,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;KAC7B;IAED,IAAW,UAAU,CAAC,KAAa,EAAA;AAC/B,QAAA,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;KAC5B;IAED,IAAW,MAAM,CAAC,KAAa,EAAA;AAC3B,QAAA,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;KACxB;IAED,IAAW,KAAK,CAAC,KAAa,EAAA;AAC1B,QAAA,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;KACvB;IAED,IAAW,GAAG,CAAC,KAAa,EAAA;AACxB,QAAA,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;KACrB;IAED,IAAW,IAAI,CAAC,KAAa,EAAA;AACzB,QAAA,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;KACtB;AAED,IAAA,IAAW,WAAW,GAAA;QAClB,OAAO,IAAI,CAAC,YAAY,CAAC;KAC5B;AAED;;AAEG;AACH,IAAA,IAAW,UAAU,GAAA;QACjB,OAAO,IAAI,CAAC,WAAW,CAAC;KAC3B;AAED,IAAA,IAAW,MAAM,GAAA;QACb,OAAO,IAAI,CAAC,OAAO,CAAC;KACvB;AAED,IAAA,IAAW,KAAK,GAAA;QACZ,OAAO,IAAI,CAAC,MAAM,CAAC;KACtB;AAED,IAAA,IAAW,GAAG,GAAA;QACV,OAAO,IAAI,CAAC,IAAI,CAAC;KACpB;AAED,IAAA,IAAW,IAAI,GAAA;QACX,OAAO,IAAI,CAAC,KAAK,CAAC;KACrB;AACJ,CAAA;AA1DG,UAAA,CAAA;IADC,UAAU;AAGV,CAAA,EAAA,qBAAA,CAAA,SAAA,EAAA,aAAA,EAAA,IAAA,CAAA;;MC3BiB,YAAY,CAAA;AAE9B,IAAA,WAAA,CACc,YAAuC,EACvC,YAAuC,EACvC,gBAAmD,EAAA;QAFnD,IAAY,CAAA,YAAA,GAAZ,YAAY,CAA2B;QACvC,IAAY,CAAA,YAAA,GAAZ,YAAY,CAA2B;QACvC,IAAgB,CAAA,gBAAA,GAAhB,gBAAgB,CAAmC;KAC5D;IAEL,IAAW,eAAe,CAAC,OAA0C,EAAA;AACjE,QAAA,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC;KACnC;AAED,IAAA,IAAW,eAAe,GAAA;QACtB,OAAO,IAAI,CAAC,gBAAgB,CAAC;KAChC;AA8BD;;AAEG;IACI,oBAAoB,CAAC,SAA8B,EAAE,KAA4B,EAAA;AAEpF,QAAA,IAAI,SAAS,KAA0B,UAAA,YAAI,KAAK,CAAC,SAAS,EAAE;AACxD,YAAA,OAAO,KAAK,CAAC;AAChB,SAAA;AAED,QAAA,IAAI,SAAS,KAA0B,YAAA,YAAI,KAAK,CAAC,SAAS,EAAE;AACxD,YAAA,OAAO,KAAK,CAAC;AAChB,SAAA;AAED,QAAA,OAAO,IAAI,CAAC;KACf;AACJ;;AC3DD;;AAEG;AACG,MAAO,sBAAuB,SAAQ,YAAY,CAAA;IAE7C,kBAAkB,GAAA;QACrB,OAAO,IAAI,CAAC,eAAe,CAAC,WAAW,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC;KACxE;IAEM,sBAAsB,GAAA;AACzB,QAAA,MAAM,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC;AAC7C,QAAA,MAAM,UAAU,GAAG,IAAI,GAAG,IAAI,CAAC,iBAAiB,EAAE,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;AAC/E,QAAA,IAAI,CAAC,YAAY,CAAC,IAAI,GAAG,UAAU,CAAC;AACpC,QAAA,OAAO,UAAU,CAAC;KACrB;AAEM,IAAA,6BAA6B,CAAC,QAAoB,EAAE,YAA+B,EAAE,MAAkB,EAAA;QAC1G,MAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC;AAClD,QAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;AAC1C,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;AAE5C,QAAA,MAAM,GAAG,GAAG,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC;AAC3C,QAAA,MAAM,IAAI,GAAG,SAAS,IAAI,UAAU,GAAG,YAAY,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC;AAErE,QAAA,OAAO,EAAC,GAAG,EAAE,IAAI,EAAC,CAAC;KACtB;IAEM,iBAAiB,GAAA;QACpB,OAAO,IAAI,CAAC,YAAY,CAAC,UAAU,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;KACnE;IAEM,kBAAkB,GAAA;AACrB,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,UAAU,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC;QAC/G,OAAO,SAAS,GAAG,EAAE,GAAG,EAAE,GAAG,SAAS,CAAC;KAC1C;AAED;;AAEG;IACI,0BAA0B,GAAA;AAC7B,QAAA,MAAM,IAAI,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAE3C,OAAO;AACH,YAAA,KAAK,EAAE,WAAW;YAClB,KAAK,EAAE,CAAe,YAAA,EAAA,IAAI,CAAW,SAAA,CAAA;SACxC,CAAC;KACL;IAEM,qBAAqB,GAAA;AACxB,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;QACxC,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,CAAG,EAAA,KAAK,CAAI,EAAA,CAAA,EAAE,CAAC;KAClD;IAEM,YAAY,GAAA;QACf,OAAO,IAAI,CAAC,eAAe,CAAC,WAAW,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC;KACxE;AAEM,IAAA,mBAAmB,CAAC,MAAyB,EAAA;QAEhD,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI;cAChD,CAAA,CAAA;AACD,8BAAgC;AAEpC,QAAA,MAAM,YAAY,GAAG;AACjB,YAAA,IAAI,EAAE,IAAI,CAAC,eAAe,CAAC,UAAU,IAAI,IAAI,CAAC,eAAe,CAAC,KAAK,GAAG,QAAQ,CAAC;AAC/E,YAAA,GAAG,EAAE,IAAI,CAAC,eAAe,CAAC,SAAS;SACtC,CAAC;AAEF,QAAA,OAAO,YAAY,CAAC;KACvB;AACJ;;ACtEK,MAAO,oBAAqB,SAAQ,YAAY,CAAA;AAElD;;AAEG;AACI,IAAA,6BAA6B,CAAC,QAAoB,EAAE,eAAkC,EAAE,MAAkB,EAAA;QAE7G,MAAM,SAAS,GAAG,QAAQ,CAAC,OAAO,GAAG,MAAM,CAAC,GAAG,CAAC;;AAEhD,QAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;;AAE1C,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;AAE5C,QAAA,MAAM,GAAG,GAAG,SAAS,IAAI,SAAS,GAAG,eAAe,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC;AACrE,QAAA,MAAM,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC;AAE7C,QAAA,OAAO,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC;KACxB;AAED;;AAEG;IACI,kBAAkB,GAAA;QACrB,OAAO,IAAI,CAAC,eAAe,CAAC,YAAY,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC;KAC1E;AAED;;AAEG;IACI,iBAAiB,GAAA;QACpB,OAAO,IAAI,CAAC,YAAY,CAAC,WAAW,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;KACpE;AAED;;AAEG;IACI,kBAAkB,GAAA;AACrB,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,WAAW,GAAG,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC;QAClH,OAAO,SAAS,GAAG,EAAE,GAAG,EAAE,GAAG,SAAS,CAAC;KAC1C;AAED;;AAEG;IACI,sBAAsB,GAAA;AACzB,QAAA,MAAM,GAAG,GAAG,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC;AAC3C,QAAA,MAAM,QAAQ,GAAG,GAAG,GAAG,IAAI,CAAC,iBAAiB,EAAE,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;AAC5E,QAAA,IAAI,CAAC,YAAY,CAAC,GAAG,GAAG,QAAQ,CAAC;AACjC,QAAA,OAAO,QAAQ,CAAC;KACnB;AAED;;AAEG;IACI,0BAA0B,GAAA;AAC7B,QAAA,MAAM,GAAG,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAC1C,OAAO;AACH,YAAA,KAAK,EAAE,WAAW;YAClB,KAAK,EAAE,CAAkB,eAAA,EAAA,GAAG,CAAQ,MAAA,CAAA;SACvC,CAAC;KACL;IAEM,qBAAqB,GAAA;AACxB,QAAA,MAAM,MAAM,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;QACzC,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAG,EAAA,MAAM,CAAI,EAAA,CAAA,EAAE,CAAC;KACpD;IAEM,YAAY,GAAA;QACf,OAAO,IAAI,CAAC,eAAe,CAAC,YAAY,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC;KAC1E;AAEM,IAAA,mBAAmB,CAAC,MAAyB,EAAA;QAEhD,MAAM,QAAQ,GAAG,MAAM,CAAC,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG;cAC9C,CAAA,CAAA;AACD,8BAAgC;AAEpC,QAAA,MAAM,YAAY,GAAG;AACjB,YAAA,GAAG,EAAE,IAAI,CAAC,eAAe,CAAC,SAAS,IAAI,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC9E,YAAA,IAAI,EAAE,IAAI,CAAC,eAAe,CAAC,UAAU;SACxC,CAAC;AAEF,QAAA,OAAO,YAAY,CAAC;KACvB;AACJ;;ACnFK,MAAO,2BAA4B,SAAQ,qBAAwD,CAAA;AAsBrG;;;AAGG;AAEI,IAAA,WAAW,CAAC,IAAuC,EAAA;AACtD,QAAA,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;KAC3B;IAED,IAAW,YAAY,CAAC,KAAa,EAAA;AACjC,QAAA,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;KAC9B;IAED,IAAW,UAAU,CAAC,KAAa,EAAA;AAC/B,QAAA,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;KAC5B;IAED,IAAW,SAAS,CAAC,KAAa,EAAA;AAC9B,QAAA,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;KAC3B;IAED,IAAW,WAAW,CAAC,KAAa,EAAA;AAChC,QAAA,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;KAC7B;AAED,IAAA,IAAW,YAAY,GAAA;QACnB,OAAO,IAAI,CAAC,aAAa,CAAC;KAC7B;AAED,IAAA,IAAW,UAAU,GAAA;QACjB,OAAO,IAAI,CAAC,WAAW,CAAC;KAC3B;AAED,IAAA,IAAW,SAAS,GAAA;QAChB,OAAO,IAAI,CAAC,UAAU,CAAC;KAC1B;AAED,IAAA,IAAW,WAAW,GAAA;QAClB,OAAO,IAAI,CAAC,YAAY,CAAC;KAC5B;AACJ,CAAA;AAnCG,UAAA,CAAA;IADC,UAAU;AAGV,CAAA,EAAA,2BAAA,CAAA,SAAA,EAAA,aAAA,EAAA,IAAA,CAAA;;AC9BL;;AAEG;MAEU,YAAY,CAAA;AA2BrB,IAAA,WAAA,CACY,IAAY,EAAA;QAAZ,IAAI,CAAA,IAAA,GAAJ,IAAI,CAAQ;AAdxB;;;;AAIG;QACK,IAAe,CAAA,eAAA,GAAG,CAAC,CAAC;QAWxB,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;AACjD,QAAA,IAAI,CAAC,OAAO,GAAG,IAAI,OAAO,EAAE,CAAC;KAChC;AAED;;AAEG;IACI,QAAQ,GAAA;;AAEX,QAAA,OAAO,UAAU,CAAC,MAAM,CAAC,QAAQ,IAAG;YAChC,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;AAEhD,YAAA,IAAI,IAAI,CAAC,eAAe,KAAK,CAAC,EAAE;gBAC5B,IAAI,CAAC,4BAA4B,EAAE,CAAC;AACvC,aAAA;;AAGD,YAAA,OAAO,MAAK;gBACR,MAAM,CAAC,WAAW,EAAE,CAAC;gBACrB,IAAI,CAAC,eAAe,EAAE,CAAC;AACvB,gBAAA,IAAI,IAAI,CAAC,eAAe,IAAI,CAAC,EAAE;AAC3B,oBAAA,IAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,CAAC;AACzC,iBAAA;AACL,aAAC,CAAC;AACN,SAAC,CAAC,CAAC;KACN;AAED;;AAEG;IACK,4BAA4B,GAAA;AAChC,QAAA,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAK;AAC7B,YAAA,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,aAAa;iBACvC,IAAI,CAAC,sBAAsB,EAAE,CAAC;iBAC9B,SAAS,CAAC,MAAM,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC;AAC9C,SAAC,CAAC,CAAC;KACN;;4HAnEQ,YAAY,EAAA,IAAA,EAAA,CAAA,EAAA,KAAA,EAAA,EAAA,CAAA,MAAA,EAAA,CAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA,CAAA;AAAZ,mBAAA,YAAA,CAAA,KAAA,GAAA,EAAA,CAAA,qBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,YAAY,cADC,MAAM,EAAA,CAAA,CAAA;2FACnB,YAAY,EAAA,UAAA,EAAA,CAAA;kBADxB,UAAU;mBAAC,EAAE,UAAU,EAAE,MAAM,EAAE,CAAA;;AAuElC,SAAS,sBAAsB,GAAA;AAE3B,IAAA,OAAO,UAAU,OAAsB,EAAA;QAEnC,IAAI,WAAW,GAAG,KAAK,CAAC;QACxB,IAAI,OAAO,GAAG,KAAK,CAAC;QAEpB,MAAM,qBAAqB,GAAG,MAAM,CAAC,qBAAqB,IAAK,MAAc,CAAC,2BAA2B,CAAC;QAE1G,MAAM,GAAG,GAAG,IAAI,UAAU,CAAI,CAAC,QAAQ,KAAI;AACvC,YAAA,SAAS,UAAU,GAAA;gBACf,IAAI,WAAW,KAAK,IAAI,EAAE;oBACtB,WAAW,GAAG,KAAK,CAAC;oBACpB,qBAAqB,CAAC,MAAK;wBACvB,QAAQ,CAAC,IAAI,EAAE,CAAC;AAChB,wBAAA,UAAU,EAAE,CAAC;AACjB,qBAAC,CAAC,CAAC;AACN,iBAAA;AAAM,qBAAA;oBACH,OAAO,GAAG,KAAK,CAAC;AACnB,iBAAA;aACJ;AAED,YAAA,OAAO,CAAC,SAAS,CAAC,MAAK;gBACnB,IAAI,OAAO,KAAK,KAAK,EAAE;oBACnB,WAAW,GAAG,IAAI,CAAC;AACnB,oBAAA,UAAU,EAAE,CAAC;AAChB,iBAAA;AACL,aAAC,CAAC,CAAC;AACP,SAAC,CAAC,CAAC;AACH,QAAA,OAAO,GAAG,CAAC;AACf,KAAC,CAAC;AACN;;ACnGA;;AAEG;MAEU,eAAe,CAAA;AAwBxB,IAAA,WAAA,CACY,MAAoB,EAAA;QAApB,IAAM,CAAA,MAAA,GAAN,MAAM,CAAc;AAjBxB,QAAA,IAAA,CAAA,QAAQ,GAAqB,IAAI,OAAO,EAAE,CAAC;AAI3C,QAAA,IAAA,CAAA,UAAU,GAAqC,IAAI,GAAG,EAAE,CAAC;AAGzD,QAAA,IAAA,CAAA,cAAc,GAAG;AACrB,YAAA,QAAQ,EAAE,CAAC;AACX,YAAA,UAAU,EAAE,CAAC;SAChB,CAAC;AASE,QAAA,IAAI,CAAC,eAAe,GAAG,IAAI,OAAO,EAAE,CAAC;QACrC,IAAI,CAAC,cAAc,GAAG,IAAI,aAAa,CAAC,CAAC,CAAC,CAAC;AAC3C,QAAA,IAAI,CAAC,eAAe,GAAG,IAAI,OAAO,EAAE,CAAC;QAErC,IAAI,CAAC,cAAc,EAAE,CAAC;KACzB;AAED;;AAEG;IACH,IAAW,QAAQ,CAAC,QAAsC,EAAA;QAEtD,IAAI,IAAI,CAAC,iBAAiB,IAAI,IAAI,CAAC,iBAAiB,KAAK,QAAQ,EAAE;YAC/D,OAAO;AACV,SAAA;QAED,IAAI,IAAI,CAAC,SAAS,EAAE;AAChB,YAAA,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;AAChC,SAAA;AAED,QAAA,IAAI,CAAC,iBAAiB,GAAG,QAAQ,CAAC;QAClC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,iBAAiB,CAAC,UAAU,EAAE;AAC/C,aAAA,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;aAC9B,SAAS,CAAC,MAAK;YACZ,IAAI,CAAC,UAAU,EAAE,CAAC;AACtB,SAAC,CAAC,CAAC;AAEP,QAAA,IAAI,CAAC,iBAAiB,CAAC,OAAO,GAAG,IAAI,CAAC;;AAGtC,QAAA,IAAI,CAAC,aAAa,GAAG,IAAI,2BAA2B,CAAC,IAAI,CAAC,iBAAiB,CAAC,WAAW,EAAE,CAAC,CAAC;QAC3F,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;AAE7C,QAAA,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,CAAC;KACjC;AAED;;;AAGG;AACI,IAAA,YAAY,CAAC,SAAsC,EAAA;QACtD,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;AACjC,YAAA,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;AAClC,SAAA;KACJ;AAED;;AAEG;AACI,IAAA,eAAe,CAAC,SAAsC,EAAA;QACzD,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;AAChC,YAAA,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;AACrC,SAAA;KACJ;AAED,IAAA,IAAW,iBAAiB,GAAA;AACxB,QAAA,OAAO,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC;KACtC;AAED,IAAA,IAAW,QAAQ,GAAA;AACf,QAAA,OAAO,IAAI,CAAC,SAAS,IAAI,KAAK,CAAC;KAClC;AAED;;;AAGG;AACI,IAAA,UAAU,CAAC,SAAiB,EAAA;AAC/B,QAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC;QAC/C,MAAM,SAAS,GAAG,IAAI,CAAC,iBAAiB,CAAC,SAAS,GAAG,QAAQ,GAAG,SAAS,CAAC;AAC1E,QAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,sBAAsB,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,GAAG,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;KAC3E;;IAGD,WAAW,GAAA;AACP,QAAA,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,CAAC;AAEjC,QAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACzB,QAAA,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,CAAC;AAC/B,QAAA,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,CAAC;AAChC,QAAA,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;AACzB,QAAA,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;AACxB,QAAA,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;AAC1B,QAAA,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;KAC1B;IAEM,MAAM,GAAA;AACT,QAAA,OAAO,IAAI,CAAC,cAAc,CAAC,YAAY,EAAE,CAAC;KAC7C;IAEM,QAAQ,GAAA;AACX,QAAA,OAAO,IAAI,CAAC,eAAe,CAAC,YAAY,EAAE,CAAC;KAC9C;AAED;;;AAGG;IACI,QAAQ,GAAA;AACX,QAAA,OAAO,IAAI,CAAC,eAAe,CAAC,YAAY,EAAE,CAAC;KAC9C;AAED;;;AAGG;IACI,MAAM,GAAA;;AAET,QAAA,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,IAAI,CAAC,iBAAiB,CAAC,WAAW,EAAE,CAAC,CAAC;QACrE,IAAI,CAAC,UAAU,CAAC,EAAE,IAAI,EAAiC,iBAAA,eAAE,CAAC,CAAC;;AAG3D,QAAA,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,IAAI,CAAC,iBAAiB,CAAC,WAAW,EAAE,CAAC,CAAC;AACrE,QAAA,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS,KAAK,SAAS,CAAC,MAAM,EAAE,CAAC,CAAC;KAC9D;AAGD;;AAEG;AACI,IAAA,QAAQ,CAAC,UAAU,EAAA;AACtB,QAAA,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,IAAI,CAAC,sBAAsB,CAAC,UAAU,CAAC,CAAC,CAAC;KAC5E;AAED;;AAEG;IACI,KAAK,GAAA;QACR,IAAI,CAAC,QAAQ,CAAC;AACV,YAAA,GAAG,EAAE,CAAC;AACN,YAAA,IAAI,EAAE,CAAC;AACV,SAAA,CAAC,CAAC;KACN;AAEM,IAAA,aAAa,CAAC,QAAiB,EAAA;AAClC,QAAA,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;KAC7B;IAEO,cAAc,GAAA;AAClB,QAAA,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE;AACjB,aAAA,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;aAC9B,SAAS,CAAC,MAAM,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;KACvC;AAED;;AAEG;IACK,UAAU,GAAA;AAEd,QAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC,cAAc,CAAC;QACvD,MAAM,SAAS,GAAG,IAAI,CAAC,cAAc,CAAC,QAAQ,KAAK,QAAQ,CAAC,GAAG,CAAC;QAChE,MAAM,SAAS,GAAG,IAAI,CAAC,cAAc,CAAC,UAAU,KAAK,QAAQ,CAAC,IAAI,CAAC;;QAGnE,IAAI,CAAC,aAAa,CAAC,UAAU,GAAG,QAAQ,CAAC,IAAI,CAAC;QAC9C,IAAI,CAAC,aAAa,CAAC,SAAS,GAAG,QAAQ,CAAC,GAAG,CAAC;AAE5C,QAAA,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC;YACtB,SAAS;YACT,SAAS;AACT,YAAA,IAAI,EAAmC,mBAAA;AAC1C,SAAA,CAAC,CAAC;QAEH,IAAI,CAAC,cAAc,CAAC,QAAQ,GAAG,QAAQ,CAAC,GAAG,CAAC;QAC5C,IAAI,CAAC,cAAc,CAAC,UAAU,GAAG,QAAQ,CAAC,IAAI,CAAC;KAClD;AAED;;AAEG;AACK,IAAA,UAAU,CAAC,KAA8C,EAAA;AAC7D,QAAA,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KACpC;AAED;;AAEG;AACK,IAAA,sBAAsB,CAAC,QAA2B,EAAA;AACtD,QAAA,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC;AAC/E,QAAA,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,WAAW,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC;AAC7E,QAAA,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,QAAQ,CAAC;QAE/B,OAAO;YACH,GAAG,EAAE,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,UAAU,GAAG,UAAU,GAAG,GAAG;YACtD,IAAI,EAAE,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,UAAU,GAAG,UAAU,GAAG,IAAI;SAC7D,CAAC;KACL;;+HArNQ,eAAe,EAAA,IAAA,EAAA,CAAA,EAAA,KAAA,EAAAA,YAAA,EAAA,CAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA,CAAA;mIAAf,eAAe,EAAA,CAAA,CAAA;2FAAf,eAAe,EAAA,UAAA,EAAA,CAAA;kBAD3B,UAAU;;;MCmBE,2BAA2B,CAAA;IAmBpC,WACgC,CAAA,kBAAmC,EACrC,QAAQ,EAC1B,MAAkB,EAClB,MAAc,EACd,QAAmB,EAAA;QAJC,IAAkB,CAAA,kBAAA,GAAlB,kBAAkB,CAAiB;QACrC,IAAQ,CAAA,QAAA,GAAR,QAAQ,CAAA;QAC1B,IAAM,CAAA,MAAA,GAAN,MAAM,CAAY;QAClB,IAAM,CAAA,MAAA,GAAN,MAAM,CAAQ;QACd,IAAQ,CAAA,QAAA,GAAR,QAAQ,CAAW;AAnBxB,QAAA,IAAA,CAAA,eAAe,GAAyB,UAAA,SAAA;AAqB3C,QAAA,IAAI,CAAC,YAAY,GAAG,IAAI,OAAO,EAAE,CAAC;KACrC;AAED;;AAEG;IACH,QAAQ,GAAA;AAEJ,QAAA,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,MAAK;YAC/B,IAAI,CAAC,mBAAmB,EAAE;AACrB,iBAAA,IAAI,CAACC,WAAS,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;AAClC,iBAAA,SAAS,EAAE,CAAC;YAEjB,IAAI,CAAC,yBAAyB,EAAE,CAAC;AACrC,SAAC,CAAC,CAAC;KACN;AAED;;AAEG;IACH,eAAe,GAAA;AAEX,QAAA,IAAI,CAAC,kBAAkB,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;;AAG3C,QAAA,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE;AAC3B,aAAA,IAAI,CAACA,WAAS,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;AAClC,aAAA,SAAS,CAAC,CAAC,OAAO,KAAK,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC;;AAGhE,QAAA,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE;AAC7B,aAAA,IAAI,CAACA,WAAS,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;AAClC,aAAA,SAAS,CAAC,CAAC,KAAK,KAAK,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC;KAC/D;AAED;;;;AAIG;IACH,WAAW,GAAA;AAEP,QAAA,IAAI,CAAC,kBAAkB,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;AAE9C,QAAA,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC7B,QAAA,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC;AAE7B,QAAA,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;AACzB,QAAA,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;AACzB,QAAA,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;AACzB,QAAA,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;KAC/B;IAEM,MAAM,GAAA;AACT,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC;AAChD,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC;QAEhD,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;AACjD,QAAA,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,SAAS,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;AAC3D,QAAA,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,SAAS,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;QAE3D,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC5B,IAAI,CAAC,mBAAmB,EAAE,CAAC;KAC9B;AAED;;AAEG;AACK,IAAA,oBAAoB,CAAC,OAA0C,EAAA;AACnE,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC;AAChD,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC;AAChD,QAAA,IAAI,CAAC,YAAY,GAAG,IAAI,qBAAqB,CAAC,SAAS,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;AAC3E,QAAA,IAAI,CAAC,YAAY,GAAG,IAAI,qBAAqB,CAAC,SAAS,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;AAC3E,QAAA,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC;QAE/B,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAC9B,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC5B,IAAI,CAAC,mBAAmB,EAAE,CAAC;KAC9B;AAED;;;AAGG;AACK,IAAA,oBAAoB,CAAC,KAA4B,EAAA;AAErD,QAAA,IAAI,IAAI,CAAC,YAAY,CAAC,oBAAoB,CAAC,IAAI,CAAC,eAAe,EAAE,KAAK,CAAC,EAAE;YACrE,OAAO;AACV,SAAA;QAED,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC5B,IAAI,CAAC,mBAAmB,EAAE,CAAC;KAC9B;AAED;;AAEG;IACK,sBAAsB,GAAA;AAE1B,QAAA,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;AACpB,YAAA,MAAM,uBAAuB,GAAG,IAAI,CAAC,eAAe,KAA0B,YAAA;AAC1E,kBAAE,sBAAsB;kBACtB,oBAAoB,CAAC;AAE3B,YAAA,IAAI,CAAC,YAAY,GAAG,IAAI,uBAAuB,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;AAC/G,SAAA;AAAM,aAAA;YACH,IAAI,CAAC,YAAY,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC;AAC5D,SAAA;KACJ;AAED;;AAEG;IACK,oBAAoB,GAAA;AACxB,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC;AAEhD,QAAA,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE,EAAE;YACnC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;AACpD,SAAA;AAAM,aAAA;YACH,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,qBAAqB,EAAE,CAAC;YAC1D,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;AAC5C,YAAA,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;AAC/D,SAAA;KACJ;AAED;;AAEG;IACK,mBAAmB,GAAA;AACvB,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC;QAChD,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,0BAA0B,EAAE,CAAC;AACjE,QAAA,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,EAAE,SAAS,CAAC,KAAK,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC;KACnE;AAED;;AAEG;IACK,yBAAyB,GAAA;AAC7B,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC;AAChD,QAAA,SAAS,CAAC,KAAK,EAAE,OAAO,CAAC;AACpB,aAAA,IAAI,CAACA,WAAS,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;AAClC,aAAA,SAAS,CAAC,CAAC,KAAiB,KAAI;YAC7B,IAAI,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,cAAc,CAAC,aAAa,EAAE;AACpD,gBAAA,OAAO,KAAK,CAAC;AAChB,aAAA;AACD,YAAA,MAAM,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,mBAAmB,CAAC,SAAS,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC;AACtF,YAAA,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;AAC7C,SAAC,CAAC,CAAC;KACV;AAED;;AAEG;IACK,mBAAmB,GAAA;AACvB,QAAA,MAAM,UAAU,GAAG,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;QAC7E,MAAM,UAAU,GAAG,SAAS,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;QACzD,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;AAE9C,QAAA,MAAM,SAAS,GAAG,UAAU,CAAC,IAAI,CAC7B,GAAG,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,aAAa,GAAG,MAAM,KAAK,CAAC,EACpD,SAAS,CAAC,CAAC,SAAqB,KAAI;AAChC,YAAA,MAAM,MAAM,GAAG,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC;YAC7E,MAAM,UAAU,GAAG,SAAS,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;AAEvD,YAAA,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC;;YAG7D,OAAO,UAAU,CAAC,IAAI,CAClB,GAAG,CAAC,CAAC,QAAoB,KAAI;AACzB,gBAAA,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAC5B,IAAI,CAAC,YAAY,CAAC,6BAA6B,CAAC,QAAQ,EAAE,UAAU,EAAE,MAAM,CAAC,CAChF,CAAC;AACN,aAAC,CAAC,EACF,QAAQ,CAAC,MAAK;AACV,gBAAA,IAAI,CAAC,QAAQ,CAAC,aAAa,GAAG,IAAI,CAAC;AACnC,gBAAA,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC;AACpE,aAAC,CAAC,EACFA,WAAS,CAAC,QAAQ,CAAC,CACtB,CAAC;SACL,CAAC,CACL,CAAC;QACF,OAAO,SAAS,CAAC,IAAI,CAACA,WAAS,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;KACvD;;AAhNQ,mBAAA,2BAAA,CAAA,IAAA,GAAA,EAAA,CAAA,kBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,2BAA2B,0EAqBxB,QAAQ,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,CAAA,UAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,CAAA,MAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,CAAA,SAAA,EAAA,CAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;AArBX,mBAAA,2BAAA,CAAA,IAAA,GAAA,EAAA,CAAA,oBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,IAAA,EAAA,2BAA2B,EAOA,QAAA,EAAA,qBAAA,EAAA,MAAA,EAAA,EAAA,eAAA,EAAA,iBAAA,EAAA,EAAA,IAAA,EAAA,EAAA,UAAA,EAAA,EAAA,OAAA,EAAA,sBAAA,EAAA,4BAAA,EAAA,sBAAA,EAAA,EAAA,EAAA,WAAA,EAAA,CAAA,EAAA,YAAA,EAAA,gBAAA,EAAA,KAAA,EAAA,IAAA,EAAA,SAAA,EAAA,CAAA,gBAAA,CAAA,EAAA,WAAA,EAAA,IAAA,EAAA,IAAA,EAAA,UAAU,EAGV,MAAA,EAAA,IAAA,EAAA,EAAA,EAAA,YAAA,EAAA,gBAAA,EAAA,KAAA,EAAA,IAAA,EAAA,SAAA,EAAA,CAAA,gBAAA,CAAA,EAAA,WAAA,EAAA,IAAA,EAAA,IAAA,EAAA,UAAU,2CCzClD,gPAKA,EAAA,MAAA,EAAA,CAAA,+UAAA,CAAA,EAAA,CAAA,CAAA;2FD0Ba,2BAA2B,EAAA,UAAA,EAAA,CAAA;kBALvC,SAAS;+BACI,qBAAqB,EAAA,QAAA,EAAA,gPAAA,EAAA,MAAA,EAAA,CAAA,+UAAA,CAAA,EAAA,CAAA;;0BAwB1B,IAAI;;0BAAI,QAAQ;;0BAChB,MAAM;2BAAC,QAAQ,CAAA;kHAhBb,eAAe,EAAA,CAAA;sBAHrB,KAAK;;sBACL,WAAW;uBAAC,OAAO,CAAA;;sBACnB,WAAW;uBAAC,4BAA4B,CAAA;gBAIjC,cAAc,EAAA,CAAA;sBADrB,SAAS;uBAAC,gBAAgB,EAAE,EAAC,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,IAAI,EAAC,CAAA;gBAIrD,cAAc,EAAA,CAAA;sBADrB,SAAS;uBAAC,gBAAgB,EAAE,EAAC,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,IAAI,EAAC,CAAA;;;AEtCjE;;;AAGG;MAEU,4CAA4C,CAAA;AAErD,IAAA,WAAA;;IAEY,gBAAkC;;IAElC,QAA0B;;IAE1B,QAAkB,EAAA;QAJlB,IAAgB,CAAA,gBAAA,GAAhB,gBAAgB,CAAkB;QAElC,IAAQ,CAAA,QAAA,GAAR,QAAQ,CAAkB;QAE1B,IAAQ,CAAA,QAAA,GAAR,QAAQ,CAAU;KACzB;IAEL,IACI,6BAA6B,CAAC,YAAqB,EAAA;AACnD,QAAA,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,IAAI,YAAY,KAAK,KAAK,EAAE;YACzE,IAAI,CAAC,gBAAgB,CAAC,kBAAkB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAC3D,SAAA;AAAM,aAAA;AACH,YAAA,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,CAAC;AACjC,SAAA;KACJ;;4JAlBQ,4CAA4C,EAAA,IAAA,EAAA,CAAA,EAAA,KAAA,EAAA,EAAA,CAAA,gBAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,CAAA,WAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,CAAA,QAAA,EAAA,CAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;gJAA5C,4CAA4C,EAAA,QAAA,EAAA,uCAAA,EAAA,MAAA,EAAA,EAAA,6BAAA,EAAA,+BAAA,EAAA,EAAA,QAAA,EAAA,EAAA,EAAA,CAAA,CAAA;2FAA5C,4CAA4C,EAAA,UAAA,EAAA,CAAA;kBADxD,SAAS;mBAAC,EAAE,QAAQ,EAAE,uCAAuC,EAAC,CAAA;wJAavD,6BAA6B,EAAA,CAAA;sBADhC,KAAK;;;MCdY,QAAQ,CAAA;AAA9B,IAAA,WAAA,GAAA;QAEc,IAAsB,CAAA,sBAAA,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC;AAE7C,QAAA,IAAA,CAAA,SAAS,GAAkB,IAAI,OAAO,EAAE,CAAC;KA6BtD;AAnBU,IAAA,OAAO,MAAiB;AAExB,IAAA,IAAI,MAAkB;IAE7B,IAAW,OAAO,CAAC,OAAyB,EAAA;AACxC,QAAA,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC;KACrC;AAED,IAAA,IAAW,OAAO,GAAA;QACd,OAAO,IAAI,CAAC,kBAAkB,CAAC;KAClC;IAEM,KAAK,GAAA;AACR,QAAA,IAAI,CAAC,QAAQ,CAAC,EAAC,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAC,CAAC,CAAC;KACpC;IAEM,UAAU,GAAA;AACb,QAAA,OAAO,IAAI,CAAC,SAAS,CAAC,YAAY,EAAE,CAAC;KACxC;AACJ;;AC9BK,MAAO,YAAa,SAAQ,QAAQ,CAAA;IAWtC,WACY,CAAA,IAAY,EACZ,OAAoB,EAAA;AAE5B,QAAA,KAAK,EAAE,CAAC;QAHA,IAAI,CAAA,IAAA,GAAJ,IAAI,CAAQ;QACZ,IAAO,CAAA,OAAA,GAAP,OAAO,CAAa;QAJxB,IAAW,CAAA,WAAA,GAAG,KAAK,CAAC;AAOxB,QAAA,IAAI,CAAC,QAAQ,GAAG,IAAI,OAAO,EAAE,CAAC;KACjC;;IAGM,IAAI,GAAA;QAEP,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC,IAAI,CAAC,OAAO,EAAE,QAAQ,CAAC;aAC3C,IAAI,CAACA,WAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QAEpC,IAAI,CAAC,cAAc,EAAE,CAAC;KACzB;IAEM,OAAO,GAAA;AAEV;;;;AAIG;QACH,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,OAAO;AACV,SAAA;AAED,QAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACzB,QAAA,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;AACzB,QAAA,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;KAC3B;AAED;;AAEG;IACI,WAAW,GAAA;QACd,OAAO,SAAS,CAAC,yBAAyB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;KAC5D;AAED;;AAEG;AACI,IAAA,QAAQ,CAAC,MAAyB,EAAA;QACrC,IAAI,sBAAsB,EAAE,EAAE;AAC1B,YAAA,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;AACjC,SAAA;AAAM,aAAA;AACH,YAAA,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,MAAM,CAAC;AAC7B,YAAA,IAAI,IAAI,IAAI,IAAI,KAAK,CAAC,EAAE;AACpB,gBAAA,IAAI,CAAC,OAAO,CAAC,UAAU,GAAG,IAAI,CAAC;AAClC,aAAA;AACD,YAAA,IAAI,GAAG,IAAI,GAAG,KAAK,CAAC,EAAE;AAClB,gBAAA,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,GAAG,CAAC;AAChC,aAAA;AACJ,SAAA;KACJ;AAED;;AAEG;AACH,IAAA,IAAW,cAAc,GAAA;QACrB,OAAO;AACH,YAAA,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS;AAC3B,YAAA,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,UAAU;SAChC,CAAC;KACL;AAED;;AAEG;IACK,cAAc,GAAA;AAClB,QAAA,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAK;AAC7B,YAAA,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,MAAK;AACxB,gBAAA,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE;AACnC,oBAAA,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC;oBACtB,OAAO;AACV,iBAAA;AACD,gBAAA,IAAI,CAAC,QAAQ,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;AACvC,aAAC,CAAC,CAAC;AACP,SAAC,CAAC,CAAC;KACN;AACJ;;ACzFD,IAAK,yBAIJ,CAAA;AAJD,CAAA,UAAK,yBAAyB,EAAA;AAC1B,IAAA,yBAAA,CAAA,SAAA,CAAA,GAAA,SAAoB,CAAA;AACpB,IAAA,yBAAA,CAAA,OAAA,CAAA,GAAA,OAAkB,CAAA;AAClB,IAAA,yBAAA,CAAA,UAAA,CAAA,GAAA,UAAqB,CAAA;AACzB,CAAC,EAJI,yBAAyB,KAAzB,yBAAyB,GAI7B,EAAA,CAAA,CAAA,CAAA;AAED;;;AAGG;MAKU,qCAAqC,CAAA;AAc9C,IAAA,WAAA,CACoB,eAAgC,EACxC,IAAY,EACZ,EAAc,EACd,QAAmB,EAAA;QAHX,IAAe,CAAA,eAAA,GAAf,eAAe,CAAiB;QACxC,IAAI,CAAA,IAAA,GAAJ,IAAI,CAAQ;QACZ,IAAE,CAAA,EAAA,GAAF,EAAE,CAAY;QACd,IAAQ,CAAA,QAAA,GAAR,QAAQ,CAAW;AAZvB,QAAA,IAAA,CAAA,OAAO,GAAiC,IAAI,OAAO,EAAE,CAAC;AAEtD,QAAA,IAAA,CAAA,eAAe,GAA8B,yBAAyB,CAAC,OAAO,CAAC;AAE/E,QAAA,IAAA,CAAA,UAAU,GAAqB,IAAI,OAAO,EAAE,CAAC;QAE7C,IAAkB,CAAA,kBAAA,GAAG,IAAI,CAAC;KAO9B;IAEJ,IACW,uBAAuB,CAAC,QAAmC,EAAA;AAClE,QAAA,IAAI,QAAQ,EAAE;AACV,YAAA,IAAI,CAAC,eAAe,GAAG,QAAQ,CAAC;AACnC,SAAA;KACJ;IAED,QAAQ,GAAA;AACJ,QAAA,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,aAAa,EAAE,oCAAoC,CAAC,CAAC;AACpF,QAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CACb,oBAAoB,EAAE,EACtB,KAAK,CAAC,GAAG,CAAC,EACV,MAAM,CAAC,CAAC,OAAO,KAAI;AACf,YAAA,MAAM,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AAC/E,YAAA,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC;AAC1B,YAAA,OAAO,UAAU,CAAC;SACrB,CAAC,EACFA,WAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAC7B,CAAC,SAAS,CAAC;YACR,IAAI,EAAE,MAAM,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE;AAC5C,SAAA,CAAC,CAAC;QAEH,QAAQ,IAAI,CAAC,eAAe;YACxB,KAAK,yBAAyB,CAAC,KAAK;gBAChC,IAAI,CAAC,wBAAwB,EAAE,CAAC;gBAChC,MAAM;AACb,SAAA;KACJ;IAED,kBAAkB,GAAA;AACd,QAAA,IAAI,IAAI,CAAC,eAAe,KAAK,yBAAyB,CAAC,OAAO,EAAE;AAC5D,YAAA,MAAM,kBAAkB,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;AACrD,YAAA,IAAI,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,kBAAkB,CAAC,KAAK,IAAI,CAAC,SAAS,CAAC,kBAAkB,CAAC,EAAE;gBAC3G,OAAO;AACV,aAAA;AACD,YAAA,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;AAC7C,YAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;AACzC,SAAA;KACJ;AAED;;;;;AAKG;IACH,WAAW,GAAA;AACP,QAAA,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;AAC5B,QAAA,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;AAC5B,QAAA,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;AACxB,QAAA,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;AAEpB,QAAA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC3B,QAAA,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC;AAC3B,QAAA,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;KAC1B;AAED;;;;;;;AAOG;IACH,eAAe,GAAA;AACX,QAAA,IAAI,CAAC,UAAU,GAAK,IAAI,CAAC,kBAAkB,EAAE,CAAC;AAC9C,QAAA,IAAI,CAAC,YAAY,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,CAAC;QACvE,IAAI,CAAC,eAAe,CAAC,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC;KACrD;AAED;;AAEG;IACK,kBAAkB,GAAA;QACtB,OAAO;AACH,YAAA,YAAY,EAAE,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,YAAY;AAChD,YAAA,WAAW,EAAE,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,WAAW;SACjD,CAAC;KACL;IAEO,wBAAwB,GAAA;QAC5B,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,aAAa,EAAE,OAAO,CAAC;AACpC,aAAA,IAAI,CAACA,WAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AAChC,aAAA,SAAS,CAAC;AACP,YAAA,IAAI,EAAE,MAAM,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE,CAAC;AAC3D,SAAA,CAAC,CAAC;KACV;;qJA5GQ,qCAAqC,EAAA,IAAA,EAAA,CAAA,EAAA,KAAA,EAAAC,eAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,CAAA,MAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,CAAA,UAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,CAAA,SAAA,EAAA,CAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;yIAArC,qCAAqC,EAAA,QAAA,EAAA,gCAAA,EAAA,MAAA,EAAA,EAAA,uBAAA,EAAA,CAAA,8BAAA,EAAA,yBAAA,CAAA,EAAA,EAAA,QAAA,EAAA,CAAA,gCAAA,CAAA,EAAA,QAAA,EAAA,EAAA,EAAA,CAAA,CAAA;2FAArC,qCAAqC,EAAA,UAAA,EAAA,CAAA;kBAJjD,SAAS;AAAC,YAAA,IAAA,EAAA,CAAA;AACP,oBAAA,QAAQ,EAAE,gCAAgC;AAC1C,oBAAA,QAAQ,EAAE,gCAAgC;AAC7C,iBAAA,CAAA;;0BAgBQ,IAAI;kHAOE,uBAAuB,EAAA,CAAA;sBADjC,KAAK;uBAAC,8BAA8B,CAAA;;;MC9C5B,QAAQ,CAAA;;AACM,QAAI,CAAA,IAAA,GAAK,MAAM,CAAC;AAChB,QAAI,CAAA,IAAA,GAAK,MAAM,CAAC;AAChB,QAAM,CAAA,MAAA,GAAG,QAAQ;;ACK5C;;;AAGG;MAEmB,0BAA0B,CAAA;AAQ5C,IAAA,WAAA;;IAEY,gBAAkC;;IAGlC,QAA0B;;AAGhB,IAAA,kBAAmC,EAC7C,cAAiC,EAAA;QAPjC,IAAgB,CAAA,gBAAA,GAAhB,gBAAgB,CAAkB;QAGlC,IAAQ,CAAA,QAAA,GAAR,QAAQ,CAAkB;QAGhB,IAAkB,CAAA,kBAAA,GAAlB,kBAAkB,CAAiB;QAC7C,IAAc,CAAA,cAAA,GAAd,cAAc,CAAmB;AAfnC,QAAA,IAAA,CAAA,QAAQ,GAAa,QAAQ,CAAC,MAAM,CAAC;QAEvC,IAAiB,CAAA,iBAAA,GAAG,KAAK,CAAC;AAe9B,QAAA,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;AACzB,QAAA,IAAI,CAAC,UAAU,GAAG,IAAI,OAAO,EAAE,CAAC;KACnC;AAED;;AAEG;IACH,SAAS,GAAA;QACL,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,IAAI,CAAC,eAAe,EAAE,CAAC;AAC1B,SAAA;AACD,QAAA,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;KAC5B;AAED;;AAEG;IACH,WAAW,GAAA;AACP,QAAA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KAC9B;AAED;;;AAGG;IACH,QAAQ,GAAA;QACJ,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,CAAC,IAAI,CACjC,GAAG,CAAC,MAAM,IAAI,CAAC,yBAAyB,EAAE,CAAC,EAC3C,SAAS,CAAC,MAAM,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,CAAC,EACnDD,WAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAC7B,CAAC,SAAS,CAAC,CAAC,WAAW,KAAI;AACxB,YAAA,MAAM,KAAK,GAAG,WAAW,CAAC,IAAI,CAAC;AAC/B,YAAA,MAAM,WAAW,GAAG,KAAK,KAAA,iBAAA,cAAqC;AAE9D,YAAA,IAAI,WAAW,EAAE;gBACb,IAAI,CAAC,yBAAyB,EAAE,CAAC;AACpC,aAAA;AACL,SAAC,CAAC,CAAC;KACN;AAID;;AAEG;IACO,yBAAyB,GAAA;AAE/B,QAAA,IAAI,UAAmB,CAAC;QAExB,QAAQ,IAAI,CAAC,QAAQ;YACjB,KAAK,QAAQ,CAAC,IAAI;gBAAE,UAAU,GAAG,KAAK,CAAC;gBAAC,MAAM;YAC9C,KAAK,QAAQ,CAAC,MAAM;gBAAE,UAAU,GAAG,IAAI,CAAC;gBAAC,MAAM;AAC/C,YAAA,SAAS,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,CAAC;AACrF,SAAA;QAED,IAAI,CAAC,WAAW,GAAG,UAAU,KAAK,IAAI,CAAC,iBAAiB,CAAC;AACzD,QAAA,IAAI,CAAC,iBAAiB,GAAG,UAAU,CAAC;QAEpC,IAAI,IAAI,CAAC,WAAW,EAAE;AAClB,YAAA,IAAI,CAAC,cAAc,CAAC,aAAa,EAAE,CAAC;AACvC,SAAA;KACJ;AAED;;;AAGG;IACK,eAAe,GAAA;QACnB,IAAI,IAAI,CAAC,iBAAiB,EAAE;YACxB,IAAI,CAAC,gBAAgB,CAAC,kBAAkB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAC3D,SAAA;AAAM,aAAA;AACH,YAAA,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,CAAC;AACjC,SAAA;KACJ;;0IA5FiB,0BAA0B,EAAA,IAAA,EAAA,CAAA,EAAA,KAAA,EAAA,EAAA,CAAA,gBAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,CAAA,WAAA,EAAA,EAAA,EAAA,KAAA,EAAAC,eAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,CAAA,iBAAA,EAAA,CAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;8HAA1B,0BAA0B,EAAA,QAAA,EAAA,EAAA,EAAA,CAAA,CAAA;2FAA1B,0BAA0B,EAAA,UAAA,EAAA,CAAA;kBAD/C,SAAS;;0BAiBD,IAAI;;;ACxBb;;AAEG;AAEG,MAAO,oCAAqC,SAAQ,0BAA0B,CAAA;IAEhF,IACW,2BAA2B,CAAC,QAAoC,EAAA;AACvE,QAAA,IAAI,QAAQ,KAAK,QAAQ,CAAC,IAAI,EAAE;AAC5B,YAAA,IAAI,CAAC,kBAAkB,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;AAC/C,SAAA;AACD,QAAA,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;KAC5B;AAES,IAAA,WAAW,CAAC,iBAAoD,EAAA;AACtE,QAAA,OAAO,iBAAiB,CAAC,YAAY,GAAG,iBAAiB,CAAC,MAAM,CAAC;KACpE;;oJAZQ,oCAAoC,EAAA,IAAA,EAAA,IAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;wIAApC,oCAAoC,EAAA,QAAA,EAAA,+BAAA,EAAA,MAAA,EAAA,EAAA,2BAAA,EAAA,6BAAA,EAAA,EAAA,eAAA,EAAA,IAAA,EAAA,QAAA,EAAA,EAAA,EAAA,CAAA,CAAA;2FAApC,oCAAoC,EAAA,UAAA,EAAA,CAAA;kBADhD,SAAS;mBAAC,EAAC,QAAQ,EAAE,+BAA+B,EAAC,CAAA;8BAIvC,2BAA2B,EAAA,CAAA;sBADrC,KAAK;;;ACLV;;;AAGG;AAEG,MAAO,oCAAqC,SAAQ,0BAA0B,CAAA;IAEhF,IACW,2BAA2B,CAAC,QAAkB,EAAA;AACrD,QAAA,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;KAC5B;AAES,IAAA,WAAW,CAAC,iBAAoD,EAAA;AACtE,QAAA,OAAO,iBAAiB,CAAC,WAAW,GAAG,iBAAiB,CAAC,KAAK,CAAC;KAClE;;oJATQ,oCAAoC,EAAA,IAAA,EAAA,IAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;wIAApC,oCAAoC,EAAA,QAAA,EAAA,+BAAA,EAAA,MAAA,EAAA,EAAA,2BAAA,EAAA,6BAAA,EAAA,EAAA,eAAA,EAAA,IAAA,EAAA,QAAA,EAAA,EAAA,EAAA,CAAA,CAAA;2FAApC,oCAAoC,EAAA,UAAA,EAAA,CAAA;kBADhD,SAAS;mBAAC,EAAE,QAAQ,EAAE,+BAA+B,EAAE,CAAA;8BAIzC,2BAA2B,EAAA,CAAA;sBADrC,KAAK;;;MCkBG,wBAAwB,CAAA;;wIAAxB,wBAAwB,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,QAAA,EAAA,CAAA,CAAA;AAAxB,mBAAA,wBAAA,CAAA,IAAA,GAAA,EAAA,CAAA,mBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,wBAAwB,iBApB7B,2BAA2B;QAC3B,4CAA4C;QAC5C,oCAAoC;QACpC,oCAAoC;QACpC,qCAAqC,CAAA,EAAA,OAAA,EAAA,CAUrC,YAAY,CAAA,EAAA,OAAA,EAAA,CAPZ,2BAA2B;QAC3B,4CAA4C;QAC5C,oCAAoC;QACpC,oCAAoC;QACpC,qCAAqC,CAAA,EAAA,CAAA,CAAA;AAShC,mBAAA,wBAAA,CAAA,IAAA,GAAA,EAAA,CAAA,mBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,wBAAwB,EAJtB,SAAA,EAAA;QACP,eAAe;KAClB,EALQ,OAAA,EAAA,CAAA;YACL,YAAY;AACf,SAAA,CAAA,EAAA,CAAA,CAAA;2FAKQ,wBAAwB,EAAA,UAAA,EAAA,CAAA;kBAtBpC,QAAQ;AAAC,YAAA,IAAA,EAAA,CAAA;AACN,oBAAA,YAAY,EAAE;wBACV,2BAA2B;wBAC3B,4CAA4C;wBAC5C,oCAAoC;wBACpC,oCAAoC;wBACpC,qCAAqC;AACxC,qBAAA;AACD,oBAAA,OAAO,EAAE;wBACL,2BAA2B;wBAC3B,4CAA4C;wBAC5C,oCAAoC;wBACpC,oCAAoC;wBACpC,qCAAqC;AACxC,qBAAA;AACD,oBAAA,OAAO,EAAE;wBACL,YAAY;AACf,qBAAA;AACD,oBAAA,SAAS,EAAE;wBACP,eAAe;AAClB,qBAAA;AACJ,iBAAA,CAAA;;;AC9BD;;AAEG;;ACFH;;AAEG;;;;"}},"fesm2015":{"code":"import * as i0 from '@angular/core';\nimport { Injectable, ElementRef, Component, Host, Optional, Inject, Input, HostBinding, ViewChild, Directive, NgModule } from '@angular/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { fromEvent, Subject, Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil as takeUntil$1, tap, switchMap, finalize, distinctUntilChanged, delay, filter } from 'rxjs/operators';\nimport { __decorate } from 'tslib';\nimport { takeUntil } from 'rxjs/internal/operators/takeUntil';\nimport * as i1 from '@angular/cdk/platform';\nimport { supportsScrollBehavior } from '@angular/cdk/platform';\n\nvar DomHelper;\r\n(function (DomHelper) {\r\n    /**\r\n     * get computed style from element\r\n     */\r\n    function getElementStyle(el, style) {\r\n        let styleValue;\r\n        try {\r\n            styleValue = getComputedStyle(el, null).getPropertyValue(style);\r\n        }\r\n        catch (e) {\r\n            styleValue = null;\r\n        }\r\n        return styleValue;\r\n    }\r\n    DomHelper.getElementStyle = getElementStyle;\r\n    function getMeasure(el) {\r\n        // get computed style not works that good and that fast like el.offsetHeight\r\n        return {\r\n            height: el.offsetHeight,\r\n            width: el.offsetWidth,\r\n            innerHeight: getInnerHeight(el),\r\n            innerWidth: getInnerWidth(el),\r\n            top: el.offsetTop,\r\n            left: el.offsetLeft\r\n        };\r\n    }\r\n    DomHelper.getMeasure = getMeasure;\r\n    function getScrollContainerMeasure(el) {\r\n        const elMeasure = getMeasure(el);\r\n        return Object.assign(Object.assign({}, elMeasure), { scrollHeight: el.scrollHeight, scrollLeft: el.scrollLeft, scrollTop: el.scrollTop, scrollWidth: el.scrollWidth });\r\n    }\r\n    DomHelper.getScrollContainerMeasure = getScrollContainerMeasure;\r\n    /**\r\n     * get element inner height, without padding\r\n     */\r\n    function getInnerHeight(el) {\r\n        /** @todo this will called alot times on resize */\r\n        const computed = getComputedStyle(el, null);\r\n        const paddingTop = parseInt(computed.getPropertyValue(\"padding-top\"), 10);\r\n        const paddingBot = parseInt(computed.getPropertyValue(\"padding-bottom\"), 10);\r\n        return el.offsetHeight - paddingTop - paddingBot;\r\n    }\r\n    DomHelper.getInnerHeight = getInnerHeight;\r\n    /**\r\n     * get elment inner width without border, margin and padding\r\n     */\r\n    function getInnerWidth(el) {\r\n        /** @todo this will called alot times on resize */\r\n        const computed = getComputedStyle(el, null);\r\n        const paddingLeft = parseInt(computed.getPropertyValue(\"padding-left\"), 10);\r\n        const paddingRight = parseInt(computed.getPropertyValue(\"padding-right\"), 10);\r\n        return el.offsetWidth - paddingLeft - paddingRight;\r\n    }\r\n    DomHelper.getInnerWidth = getInnerWidth;\r\n    /**\r\n     * get element bounds\r\n     */\r\n    function getElementBounds(el) {\r\n        return el.getBoundingClientRect();\r\n    }\r\n    DomHelper.getElementBounds = getElementBounds;\r\n    /**\r\n     * calclulate offsetX / offsetY for MouseEvents\r\n     * we could use event.offsetX or event.offsetY but this is experimental\r\n     * and not working correctly in FF for some times.\r\n     */\r\n    function getMouseOffset(event) {\r\n        const rect = event.currentTarget.getBoundingClientRect();\r\n        return {\r\n            left: event.clientX - rect.left,\r\n            top: event.clientY - rect.top\r\n        };\r\n    }\r\n    DomHelper.getMouseOffset = getMouseOffset;\r\n})(DomHelper || (DomHelper = {}));\n\nfunction importData(target, key = null, descriptor) {\r\n    if (!descriptor) {\r\n        descriptor = Object.getOwnPropertyDescriptor(target, key);\r\n    }\r\n    const originalMethod = descriptor.value;\r\n    descriptor.value = function (data) {\r\n        // get all properties, exclude decorated property\r\n        Object.keys(data).forEach((property) => {\r\n            this[property] = data[property];\r\n        });\r\n        // call original descriptor\r\n        const result = originalMethod.call(this, data);\r\n        return result;\r\n    };\r\n    return descriptor;\r\n}\n\n/**\r\n * viewport model so save / share current state from viewport\r\n */\r\nclass ContainerMeasureModel {\r\n    constructor(data) {\r\n        this.setMeasures(data);\r\n    }\r\n    setMeasures(data) {\r\n        this._measure = data;\r\n    }\r\n    get measures() {\r\n        return Object.assign({}, this._measure);\r\n    }\r\n    set innerHeight(value) {\r\n        this._innerHeight = value;\r\n    }\r\n    set innerWidth(value) {\r\n        this._innerWidth = value;\r\n    }\r\n    set height(value) {\r\n        this._height = value;\r\n    }\r\n    set width(value) {\r\n        this._width = value;\r\n    }\r\n    set top(value) {\r\n        this._top = value;\r\n    }\r\n    set left(value) {\r\n        this._left = value;\r\n    }\r\n    get innerHeight() {\r\n        return this._innerHeight;\r\n    }\r\n    /**\r\n     * @returns number\r\n     */\r\n    get innerWidth() {\r\n        return this._innerWidth;\r\n    }\r\n    get height() {\r\n        return this._height;\r\n    }\r\n    get width() {\r\n        return this._width;\r\n    }\r\n    get top() {\r\n        return this._top;\r\n    }\r\n    get left() {\r\n        return this._left;\r\n    }\r\n}\r\n__decorate([\r\n    importData\r\n], ContainerMeasureModel.prototype, \"setMeasures\", null);\n\nclass ScrollHelper {\r\n    constructor(thumbMeasure, trackMeasure, _viewportMeasure) {\r\n        this.thumbMeasure = thumbMeasure;\r\n        this.trackMeasure = trackMeasure;\r\n        this._viewportMeasure = _viewportMeasure;\r\n    }\r\n    set viewportMeasure(measure) {\r\n        this._viewportMeasure = measure;\r\n    }\r\n    get viewportMeasure() {\r\n        return this._viewportMeasure;\r\n    }\r\n    /**\r\n     * return true if we could skip scroll event otherwise false\r\n     */\r\n    couldSkipScrollEvent(direction, event) {\r\n        if (direction === \"vertical\" /* Y */ && event.scrolledY) {\r\n            return false;\r\n        }\r\n        if (direction === \"horizontal\" /* X */ && event.scrolledX) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\n\n/**\r\n * helper for calculations on vertical scrollbars\r\n */\r\nclass HorizontalScrollHelper extends ScrollHelper {\r\n    calculateScrollMax() {\r\n        return this.viewportMeasure.scrollWidth - this.viewportMeasure.width;\r\n    }\r\n    calculateThumbPosition() {\r\n        const left = this.viewportMeasure.scrollLeft;\r\n        const offsetLeft = left * this.calculateTrackMax() / this.calculateScrollMax();\r\n        this.thumbMeasure.left = offsetLeft;\r\n        return offsetLeft;\r\n    }\r\n    calculateDragDropScrollOffset(dragMove, dragDroffset, offset) {\r\n        const offsetLeft = dragMove.clientX - offset.left;\r\n        const trackMax = this.calculateTrackMax();\r\n        const scrollMax = this.calculateScrollMax();\r\n        const top = this.viewportMeasure.scrollTop;\r\n        const left = scrollMax * (offsetLeft - dragDroffset.left) / trackMax;\r\n        return { top, left };\r\n    }\r\n    calculateTrackMax() {\r\n        return this.trackMeasure.innerWidth - this.calculateThumbSize();\r\n    }\r\n    calculateThumbSize() {\r\n        const thumbSize = this.viewportMeasure.width * this.trackMeasure.innerWidth / this.viewportMeasure.scrollWidth;\r\n        return thumbSize < 20 ? 20 : thumbSize;\r\n    }\r\n    /**\r\n     * returns thumb transform property\r\n     */\r\n    getScrollThumbCssTransform() {\r\n        const left = this.calculateThumbPosition();\r\n        return {\r\n            style: \"transform\",\r\n            value: `translate3d(${left}px, 0, 0)`\r\n        };\r\n    }\r\n    getScrollThumbCssSize() {\r\n        const width = this.calculateThumbSize();\r\n        return { style: \"width\", value: `${width}px` };\r\n    }\r\n    isScrollable() {\r\n        return this.viewportMeasure.scrollWidth > this.viewportMeasure.width;\r\n    }\r\n    calculatePageScroll(offset) {\r\n        const modifier = offset.left < this.thumbMeasure.left\r\n            ? -1 /* BACK */\r\n            : 1 /* FORWARD */;\r\n        const scrollOffset = {\r\n            left: this.viewportMeasure.scrollLeft + (this.viewportMeasure.width * modifier),\r\n            top: this.viewportMeasure.scrollTop\r\n        };\r\n        return scrollOffset;\r\n    }\r\n}\n\nclass VerticalScrollHelper extends ScrollHelper {\r\n    /**\r\n     * calculate offset we have scrolled on viewport\r\n     */\r\n    calculateDragDropScrollOffset(dragMove, dragStartOffset, offset) {\r\n        const offsetTop = dragMove.clientY - offset.top;\r\n        /** @TODO dont calculate this every time, this will not change on drag drop */\r\n        const trackMax = this.calculateTrackMax();\r\n        /** @TODO dont calculate this every time, this will not change on drag drop */\r\n        const scrollMax = this.calculateScrollMax();\r\n        const top = scrollMax * (offsetTop - dragStartOffset.top) / trackMax;\r\n        const left = this.viewportMeasure.scrollLeft;\r\n        return { top, left };\r\n    }\r\n    /**\r\n     * calculate max scroll position on viewport\r\n     */\r\n    calculateScrollMax() {\r\n        return this.viewportMeasure.scrollHeight - this.viewportMeasure.height;\r\n    }\r\n    /**\r\n     * calculate max track position for scrollThumb\r\n     */\r\n    calculateTrackMax() {\r\n        return this.trackMeasure.innerHeight - this.calculateThumbSize();\r\n    }\r\n    /**\r\n     * calculate thumbnail size\r\n     */\r\n    calculateThumbSize() {\r\n        const thumbSize = this.viewportMeasure.height * this.trackMeasure.innerHeight / this.viewportMeasure.scrollHeight;\r\n        return thumbSize < 20 ? 20 : thumbSize;\r\n    }\r\n    /**\r\n     * calculate scrollthumb position, set position for thumb\r\n     */\r\n    calculateThumbPosition() {\r\n        const top = this.viewportMeasure.scrollTop;\r\n        const valueTop = top * this.calculateTrackMax() / this.calculateScrollMax();\r\n        this.thumbMeasure.top = valueTop;\r\n        return valueTop;\r\n    }\r\n    /**\r\n     * returns thumb transform property\r\n     */\r\n    getScrollThumbCssTransform() {\r\n        const top = this.calculateThumbPosition();\r\n        return {\r\n            style: \"transform\",\r\n            value: `translate3d(0, ${top}px, 0)`\r\n        };\r\n    }\r\n    getScrollThumbCssSize() {\r\n        const height = this.calculateThumbSize();\r\n        return { style: \"height\", value: `${height}px` };\r\n    }\r\n    isScrollable() {\r\n        return this.viewportMeasure.scrollHeight > this.viewportMeasure.height;\r\n    }\r\n    calculatePageScroll(offset) {\r\n        const modifier = offset.top < this.thumbMeasure.top\r\n            ? -1 /* BACK */\r\n            : 1 /* FORWARD */;\r\n        const scrollOffset = {\r\n            top: this.viewportMeasure.scrollTop + (this.viewportMeasure.height * modifier),\r\n            left: this.viewportMeasure.scrollLeft\r\n        };\r\n        return scrollOffset;\r\n    }\r\n}\n\nclass ScrollContainerMeasureModel extends ContainerMeasureModel {\r\n    /**\r\n     * set measure data automatically imports data\r\n     * to model\r\n     */\r\n    setMeasures(data) {\r\n        super.setMeasures(data);\r\n    }\r\n    set scrollHeight(value) {\r\n        this._scrollHeight = value;\r\n    }\r\n    set scrollLeft(value) {\r\n        this._scrollLeft = value;\r\n    }\r\n    set scrollTop(value) {\r\n        this._scrollTop = value;\r\n    }\r\n    set scrollWidth(value) {\r\n        this._scrollWidth = value;\r\n    }\r\n    get scrollHeight() {\r\n        return this._scrollHeight;\r\n    }\r\n    get scrollLeft() {\r\n        return this._scrollLeft;\r\n    }\r\n    get scrollTop() {\r\n        return this._scrollTop;\r\n    }\r\n    get scrollWidth() {\r\n        return this._scrollWidth;\r\n    }\r\n}\r\n__decorate([\r\n    importData\r\n], ScrollContainerMeasureModel.prototype, \"setMeasures\", null);\n\n/**\r\n *\r\n */\r\nclass WindowResize {\r\n    constructor(zone) {\r\n        this.zone = zone;\r\n        /**\r\n         * current subscriber count on shared stream, the first subscriber\r\n         * will trigger shared stream registration on window resize stream\r\n         * if all subscribers are removed we automatically remove from\r\n         */\r\n        this.subscriberCount = 0;\r\n        this.windowResize$ = fromEvent(window, \"resize\");\r\n        this.shared$ = new Subject();\r\n    }\r\n    /**\r\n     * create shared event stream and register to this\r\n     */\r\n    onChange() {\r\n        // subscribe\r\n        return Observable.create(observer => {\r\n            this.subscriberCount++;\r\n            const event$ = this.shared$.subscribe(observer);\r\n            if (this.subscriberCount === 1) {\r\n                this.subscribeToWindowResizeEvent();\r\n            }\r\n            // unsubscribe\r\n            return () => {\r\n                event$.unsubscribe();\r\n                this.subscriberCount--;\r\n                if (this.subscriberCount <= 0) {\r\n                    this.resizeSubscription.unsubscribe();\r\n                }\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * register to window resize events\r\n     */\r\n    subscribeToWindowResizeEvent() {\r\n        this.zone.runOutsideAngular(() => {\r\n            this.resizeSubscription = this.windowResize$\r\n                .pipe(debounceAnimationFrame())\r\n                .subscribe(() => this.shared$.next());\r\n        });\r\n    }\r\n}\r\n/** @nocollapse */ WindowResize.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: WindowResize, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ WindowResize.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: WindowResize, providedIn: \"root\" });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: WindowResize, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: \"root\" }]\r\n        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });\r\nfunction debounceAnimationFrame() {\r\n    return function (source$) {\r\n        let resizeFired = false;\r\n        let drawing = false;\r\n        const requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame;\r\n        const obs = new Observable((observer) => {\r\n            function drawResize() {\r\n                if (resizeFired === true) {\r\n                    resizeFired = false;\r\n                    requestAnimationFrame(() => {\r\n                        observer.next();\r\n                        drawResize();\r\n                    });\r\n                }\r\n                else {\r\n                    drawing = false;\r\n                }\r\n            }\r\n            source$.subscribe(() => {\r\n                if (drawing === false) {\r\n                    resizeFired = true;\r\n                    drawResize();\r\n                }\r\n            });\r\n        });\r\n        return obs;\r\n    };\r\n}\n\n/**\r\n * viewport contol service, the glue between scrollbars and the viewport\r\n */\r\nclass ViewportControl {\r\n    constructor(resize) {\r\n        this.resize = resize;\r\n        this.destroy$ = new Subject();\r\n        this.scrollbars = new Set();\r\n        this.scrollPosition = {\r\n            vertical: 0,\r\n            horizontal: 0\r\n        };\r\n        this.viewportUpdate$ = new Subject();\r\n        this.viewportReady$ = new ReplaySubject(1);\r\n        this.viewportScroll$ = new Subject();\r\n        this.registerEvents();\r\n    }\r\n    /**\r\n     * inject the viewport which should be scrolled\r\n     */\r\n    set viewPort(viewPort) {\r\n        if (this.scrollbarViewPort && this.scrollbarViewPort === viewPort) {\r\n            return;\r\n        }\r\n        if (this.scrollSub) {\r\n            this.scrollSub.unsubscribe();\r\n        }\r\n        this.scrollbarViewPort = viewPort;\r\n        this.scrollSub = this.scrollbarViewPort.onScrolled()\r\n            .pipe(takeUntil(this.destroy$))\r\n            .subscribe(() => {\r\n            this.onScrolled();\r\n        });\r\n        this.scrollbarViewPort.control = this;\r\n        /** create new viewport model if a viewport has been bound */\r\n        this.viewportModel = new ScrollContainerMeasureModel(this.scrollbarViewPort.measureSize());\r\n        this.viewportReady$.next(this.viewportModel);\r\n        this.scrollbarViewPort.init();\r\n    }\r\n    /**\r\n     * register scrollbar to viewport so we could render them\r\n     * programatically if we need to do\r\n     */\r\n    addScrollbar(scrollbar) {\r\n        if (!this.scrollbars.has(scrollbar)) {\r\n            this.scrollbars.add(scrollbar);\r\n        }\r\n    }\r\n    /**\r\n     * remove scrollbar to viewport\r\n     */\r\n    removeScrollbar(scrollbar) {\r\n        if (this.scrollbars.has(scrollbar)) {\r\n            this.scrollbars.delete(scrollbar);\r\n        }\r\n    }\r\n    get viewportDimension() {\r\n        return this.viewportModel.measures;\r\n    }\r\n    get disabled() {\r\n        return this._disabled || false;\r\n    }\r\n    /**\r\n     * scroll page by specific amount\r\n     * move this to helper\r\n     */\r\n    scrollPage(direction) {\r\n        const pageSize = this.viewportDimension.height;\r\n        const scrollTop = this.viewportDimension.scrollTop + pageSize * direction;\r\n        this.scrollTo(this.sanitizeScrollPosition({ left: 0, top: scrollTop }));\r\n    }\r\n    /** not called if i just reload this */\r\n    ngOnDestroy() {\r\n        this.scrollbarViewPort.destroy();\r\n        this.destroy$.next(true);\r\n        this.viewportReady$.complete();\r\n        this.viewportUpdate$.complete();\r\n        this.destroy$.complete();\r\n        this.scrollbars.clear();\r\n        this.viewportModel = null;\r\n        this.scrollbars = null;\r\n    }\r\n    onLoad() {\r\n        return this.viewportReady$.asObservable();\r\n    }\r\n    onScroll() {\r\n        return this.viewportScroll$.asObservable();\r\n    }\r\n    /**\r\n     * returns observable to get notified if viewport\r\n     * has been changed in scroll or has been refreshed\r\n     */\r\n    onUpdate() {\r\n        return this.viewportUpdate$.asObservable();\r\n    }\r\n    /**\r\n     * viewport was changed, this could happen if new content, or window has been resized\r\n     * has been added or removed\r\n     */\r\n    update() {\r\n        /** triggers soft update to trigger directives */\r\n        this.viewportModel.setMeasures(this.scrollbarViewPort.measureSize());\r\n        this.emitUpdate({ type: \"viewport_update\" /* UPDATE */ });\r\n        /** get size again and trigger update for scrollbars */\r\n        this.viewportModel.setMeasures(this.scrollbarViewPort.measureSize());\r\n        this.scrollbars.forEach((scrollbar) => scrollbar.render());\r\n    }\r\n    /**\r\n     * viewport should scroll by specific amount\r\n     */\r\n    scrollTo(scrolledTo) {\r\n        this.scrollbarViewPort.scrollTo(this.sanitizeScrollPosition(scrolledTo));\r\n    }\r\n    /**\r\n     * scroll viewport to origin\r\n     */\r\n    reset() {\r\n        this.scrollTo({\r\n            top: 0,\r\n            left: 0\r\n        });\r\n    }\r\n    disableScroll(disabled) {\r\n        this._disabled = disabled;\r\n    }\r\n    registerEvents() {\r\n        this.resize.onChange()\r\n            .pipe(takeUntil(this.destroy$))\r\n            .subscribe(() => this.update());\r\n    }\r\n    /**\r\n     * viewport has been scrolled\r\n     */\r\n    onScrolled() {\r\n        const scrolled = this.scrollbarViewPort.scrolledOffset;\r\n        const scrolledY = this.scrollPosition.vertical !== scrolled.top;\r\n        const scrolledX = this.scrollPosition.horizontal !== scrolled.left;\r\n        // update model to set current scroll offsets\r\n        this.viewportModel.scrollLeft = scrolled.left;\r\n        this.viewportModel.scrollTop = scrolled.top;\r\n        this.viewportScroll$.next({\r\n            scrolledY,\r\n            scrolledX,\r\n            type: \"viewport_scrolled\" /* SCROLLED */\r\n        });\r\n        this.scrollPosition.vertical = scrolled.top;\r\n        this.scrollPosition.horizontal = scrolled.left;\r\n    }\r\n    /**\r\n     * emits an update event through viewportUpdate observable\r\n     */\r\n    emitUpdate(event) {\r\n        this.viewportUpdate$.next(event);\r\n    }\r\n    /**\r\n     * sanitize scroll position to ensure we not scroll over the bounds\r\n     */\r\n    sanitizeScrollPosition(scrollTo) {\r\n        const scrollMaxY = this.viewportModel.scrollHeight - this.viewportModel.height;\r\n        const scrollMaxX = this.viewportModel.scrollWidth - this.viewportModel.width;\r\n        const { top, left } = scrollTo;\r\n        return {\r\n            top: top < 0 ? 0 : top > scrollMaxY ? scrollMaxY : top,\r\n            left: left < 0 ? 0 : left > scrollMaxX ? scrollMaxX : left,\r\n        };\r\n    }\r\n}\r\n/** @nocollapse */ ViewportControl.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: ViewportControl, deps: [{ token: WindowResize }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ ViewportControl.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: ViewportControl });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: ViewportControl, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: WindowResize }]; } });\n\nclass NgxCustomScrollbarComponent {\r\n    constructor(viewportController, document, hostEl, ngZone, renderer) {\r\n        this.viewportController = viewportController;\r\n        this.document = document;\r\n        this.hostEl = hostEl;\r\n        this.ngZone = ngZone;\r\n        this.renderer = renderer;\r\n        this.scrollDirection = \"vertical\" /* Y */;\r\n        this.isDestroyed$ = new Subject();\r\n    }\r\n    /**\r\n     * initialize scrollbar track and scrollbar thumb events\r\n     */\r\n    ngOnInit() {\r\n        this.ngZone.runOutsideAngular(() => {\r\n            this.registerThumbEvents()\r\n                .pipe(takeUntil$1(this.isDestroyed$))\r\n                .subscribe();\r\n            this.registerScrollTrackEvents();\r\n        });\r\n    }\r\n    /**\r\n     * dom is rendered and initialized\r\n     */\r\n    ngAfterViewInit() {\r\n        this.viewportController.addScrollbar(this);\r\n        /** viewport has been attached */\r\n        this.viewportController.onLoad()\r\n            .pipe(takeUntil$1(this.isDestroyed$))\r\n            .subscribe((measure) => this.handleViewportLoaded(measure));\r\n        /** viewport has been updated in size or is scrolled */\r\n        this.viewportController.onScroll()\r\n            .pipe(takeUntil$1(this.isDestroyed$))\r\n            .subscribe((event) => this.handleViewportScroll(event));\r\n    }\r\n    /**\r\n     * compoenent gets destroyed remove\r\n     * emit true to isDestroyed to remove subscriptions\r\n     * from all streams\r\n     */\r\n    ngOnDestroy() {\r\n        this.viewportController.removeScrollbar(this);\r\n        this.isDestroyed$.next(true);\r\n        this.isDestroyed$.complete();\r\n        this.scrollHelper = null;\r\n        this.thumbMeasure = null;\r\n        this.trackMeasure = null;\r\n        this.viewportMeasure = null;\r\n    }\r\n    render() {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n        const track = this.scrollbarTrack.nativeElement;\r\n        this.renderer.setStyle(thumb, \"display\", \"none\");\r\n        this.trackMeasure.setMeasures(DomHelper.getMeasure(track));\r\n        this.thumbMeasure.setMeasures(DomHelper.getMeasure(thumb));\r\n        this.renderScrollbarThumb();\r\n        this.moveThumbToPosition();\r\n    }\r\n    /**\r\n     * a viewport has been added to viewport controller\r\n     */\r\n    handleViewportLoaded(measure) {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n        const track = this.scrollbarTrack.nativeElement;\r\n        this.thumbMeasure = new ContainerMeasureModel(DomHelper.getMeasure(thumb));\r\n        this.trackMeasure = new ContainerMeasureModel(DomHelper.getMeasure(track));\r\n        this.viewportMeasure = measure;\r\n        this.initializeScrollHelper();\r\n        this.renderScrollbarThumb();\r\n        this.moveThumbToPosition();\r\n    }\r\n    /**\r\n     * viewportControl sends update, this could be\r\n     * initialized, scrolled or content changes\r\n     */\r\n    handleViewportScroll(event) {\r\n        if (this.scrollHelper.couldSkipScrollEvent(this.scrollDirection, event)) {\r\n            return;\r\n        }\r\n        this.renderScrollbarThumb();\r\n        this.moveThumbToPosition();\r\n    }\r\n    /**\r\n     * initialize scroll helpers\r\n     */\r\n    initializeScrollHelper() {\r\n        if (!this.scrollHelper) {\r\n            const scrollHelperConstructor = this.scrollDirection === \"horizontal\" /* X */\r\n                ? HorizontalScrollHelper\r\n                : VerticalScrollHelper;\r\n            this.scrollHelper = new scrollHelperConstructor(this.thumbMeasure, this.trackMeasure, this.viewportMeasure);\r\n        }\r\n        else {\r\n            this.scrollHelper.viewportMeasure = this.viewportMeasure;\r\n        }\r\n    }\r\n    /**\r\n     * renders scrollbar thumb\r\n     */\r\n    renderScrollbarThumb() {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n        if (!this.scrollHelper.isScrollable()) {\r\n            this.renderer.setStyle(thumb, \"display\", \"none\");\r\n        }\r\n        else {\r\n            const cssSize = this.scrollHelper.getScrollThumbCssSize();\r\n            this.renderer.removeStyle(thumb, \"display\");\r\n            this.renderer.setStyle(thumb, cssSize.style, cssSize.value);\r\n        }\r\n    }\r\n    /**\r\n     * move thumb to position after viewport has been scrolled\r\n     */\r\n    moveThumbToPosition() {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n        const scrollCSS = this.scrollHelper.getScrollThumbCssTransform();\r\n        this.renderer.setStyle(thumb, scrollCSS.style, scrollCSS.value);\r\n    }\r\n    /**\r\n     * register scrollbar track click event to scroll a page\r\n     */\r\n    registerScrollTrackEvents() {\r\n        const track = this.scrollbarTrack.nativeElement;\r\n        fromEvent(track, \"click\")\r\n            .pipe(takeUntil$1(this.isDestroyed$))\r\n            .subscribe((event) => {\r\n            if (event.target === this.scrollbarThumb.nativeElement) {\r\n                return false;\r\n            }\r\n            const offset = this.scrollHelper.calculatePageScroll(DomHelper.getMouseOffset(event));\r\n            this.viewportController.scrollTo(offset);\r\n        });\r\n    }\r\n    /**\r\n     * handle drag drop on scrollbar thumb\r\n     */\r\n    registerThumbEvents() {\r\n        const mouseDown$ = fromEvent(this.scrollbarThumb.nativeElement, \"mousedown\");\r\n        const mouseMove$ = fromEvent(this.document, \"mousemove\");\r\n        const mouseUp$ = fromEvent(window, \"mouseup\");\r\n        const dragDrop$ = mouseDown$.pipe(tap(() => this.document.onselectstart = () => false), switchMap((dragStart) => {\r\n            const offset = DomHelper.getElementBounds(this.scrollbarTrack.nativeElement);\r\n            const dragOffset = DomHelper.getMouseOffset(dragStart);\r\n            this.renderer.addClass(this.hostEl.nativeElement, \"dragged\");\r\n            /** switch to mousemove stream until we press mouse button */\r\n            return mouseMove$.pipe(tap((dragMove) => {\r\n                this.viewportController.scrollTo(this.scrollHelper.calculateDragDropScrollOffset(dragMove, dragOffset, offset));\r\n            }), finalize(() => {\r\n                this.document.onselectstart = null;\r\n                this.renderer.removeClass(this.hostEl.nativeElement, \"dragged\");\r\n            }), takeUntil$1(mouseUp$));\r\n        }));\r\n        return dragDrop$.pipe(takeUntil$1(this.isDestroyed$));\r\n    }\r\n}\r\n/** @nocollapse */ NgxCustomScrollbarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarComponent, deps: [{ token: ViewportControl, host: true, optional: true }, { token: DOCUMENT }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });\r\n/** @nocollapse */ NgxCustomScrollbarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.3.6\", type: NgxCustomScrollbarComponent, selector: \"ngx-customscrollbar\", inputs: { scrollDirection: \"scrollDirection\" }, host: { properties: { \"class\": \"this.scrollDirection\", \"class.ngx-customscrollbars\": \"this.scrollDirection\" } }, viewQueries: [{ propertyName: \"scrollbarTrack\", first: true, predicate: [\"scrollbarTrack\"], descendants: true, read: ElementRef, static: true }, { propertyName: \"scrollbarThumb\", first: true, predicate: [\"scrollbarThumb\"], descendants: true, read: ElementRef, static: true }], ngImport: i0, template: \"<div class=\\\"scrollbar-up\\\" #scrollbarTopLeft></div>\\r\\n<div class=\\\"scrollbar-track\\\" #scrollbarTrack>\\r\\n    <div class=\\\"scrollbar-thumb\\\" #scrollbarThumb></div>\\r\\n</div>\\r\\n<div class=\\\"scrollbar-up\\\" #scrollbarRightBottom></div>\\r\\n\", styles: [\":host{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;display:flex}:host.vertical{-moz-flex-direction:column;flex-direction:column}:host.vertical .scrollbar-thumb{width:100%}:host.horizontal{-moz-flex-direction:row;flex-direction:row}:host.horizontal .scrollbar-thumb{height:100%}:host .scrollbar-track{flex:1}\\n\"] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarComponent, decorators: [{\r\n            type: Component,\r\n            args: [{ selector: \"ngx-customscrollbar\", template: \"<div class=\\\"scrollbar-up\\\" #scrollbarTopLeft></div>\\r\\n<div class=\\\"scrollbar-track\\\" #scrollbarTrack>\\r\\n    <div class=\\\"scrollbar-thumb\\\" #scrollbarThumb></div>\\r\\n</div>\\r\\n<div class=\\\"scrollbar-up\\\" #scrollbarRightBottom></div>\\r\\n\", styles: [\":host{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;display:flex}:host.vertical{-moz-flex-direction:column;flex-direction:column}:host.vertical .scrollbar-thumb{width:100%}:host.horizontal{-moz-flex-direction:row;flex-direction:row}:host.horizontal .scrollbar-thumb{height:100%}:host .scrollbar-track{flex:1}\\n\"] }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: ViewportControl, decorators: [{\r\n                        type: Host\r\n                    }, {\r\n                        type: Optional\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }];\r\n    }, propDecorators: { scrollDirection: [{\r\n                type: Input\r\n            }, {\r\n                type: HostBinding,\r\n                args: [\"class\"]\r\n            }, {\r\n                type: HostBinding,\r\n                args: [\"class.ngx-customscrollbars\"]\r\n            }], scrollbarTrack: [{\r\n                type: ViewChild,\r\n                args: [\"scrollbarTrack\", { read: ElementRef, static: true }]\r\n            }], scrollbarThumb: [{\r\n                type: ViewChild,\r\n                args: [\"scrollbarThumb\", { read: ElementRef, static: true }]\r\n            }] } });\n\n/**\r\n * dont show element if we can support styles of scrollbar\r\n * only via css. Possible with webkit / BLINK (chrome, chromium, opera)\r\n */\r\nclass NgxCustomScrollbarHideOnNativeStyleDirective {\r\n    constructor(\r\n    /** The view container to add items to. */\r\n    viewContainerRef, \r\n    /** The template to use when stamping out new items. */\r\n    template, \r\n    /** platform */\r\n    platform) {\r\n        this.viewContainerRef = viewContainerRef;\r\n        this.template = template;\r\n        this.platform = platform;\r\n    }\r\n    set q2gScrollbarHideOnNativeStyle(hideOnNative) {\r\n        if (!this.platform.WEBKIT && !this.platform.BLINK || hideOnNative === false) {\r\n            this.viewContainerRef.createEmbeddedView(this.template);\r\n        }\r\n        else {\r\n            this.viewContainerRef.clear();\r\n        }\r\n    }\r\n}\r\n/** @nocollapse */ NgxCustomScrollbarHideOnNativeStyleDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarHideOnNativeStyleDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: i1.Platform }], target: i0.ɵɵFactoryTarget.Directive });\r\n/** @nocollapse */ NgxCustomScrollbarHideOnNativeStyleDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.6\", type: NgxCustomScrollbarHideOnNativeStyleDirective, selector: \"[ngxCustomScrollbarHideOnNativeStyle]\", inputs: { q2gScrollbarHideOnNativeStyle: \"q2gScrollbarHideOnNativeStyle\" }, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarHideOnNativeStyleDirective, decorators: [{\r\n            type: Directive,\r\n            args: [{ selector: \"[ngxCustomScrollbarHideOnNativeStyle]\" }]\r\n        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: i1.Platform }]; }, propDecorators: { q2gScrollbarHideOnNativeStyle: [{\r\n                type: Input\r\n            }] } });\n\nclass Viewport {\r\n    constructor() {\r\n        this.viewportScrolledOffset = { top: 0, left: 0 };\r\n        this.scrolled$ = new Subject();\r\n    }\r\n    destroy() { }\r\n    init() { }\r\n    set control(control) {\r\n        this.viewPortController = control;\r\n    }\r\n    get control() {\r\n        return this.viewPortController;\r\n    }\r\n    reset() {\r\n        this.scrollTo({ top: 0, left: 0 });\r\n    }\r\n    onScrolled() {\r\n        return this.scrolled$.asObservable();\r\n    }\r\n}\n\nclass HtmlViewport extends Viewport {\r\n    constructor(zone, element) {\r\n        super();\r\n        this.zone = zone;\r\n        this.element = element;\r\n        this.isDestroyed = false;\r\n        this.destroy$ = new Subject();\r\n    }\r\n    /** element is bound to viewport */\r\n    init() {\r\n        this.scroll$ = fromEvent(this.element, \"scroll\")\r\n            .pipe(takeUntil$1(this.destroy$));\r\n        this.registerEvents();\r\n    }\r\n    destroy() {\r\n        /**\r\n         * component gets allready destroyed\r\n         * could happens twice if we create this with directive which destroys the viewport\r\n         * or we destroy the whole component which provides viewport control\r\n         */\r\n        if (this.isDestroyed) {\r\n            return;\r\n        }\r\n        this.destroy$.next(true);\r\n        this.destroy$.complete();\r\n        this.isDestroyed = true;\r\n    }\r\n    /**\r\n     * get container dimensions\r\n     */\r\n    measureSize() {\r\n        return DomHelper.getScrollContainerMeasure(this.element);\r\n    }\r\n    /**\r\n     * scroll viewport to specific position\r\n     */\r\n    scrollTo(offset) {\r\n        if (supportsScrollBehavior()) {\r\n            this.element.scrollTo(offset);\r\n        }\r\n        else {\r\n            const { top, left } = offset;\r\n            if (left || left === 0) {\r\n                this.element.scrollLeft = left;\r\n            }\r\n            if (top || top === 0) {\r\n                this.element.scrollTop = top;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * get scrolled offset\r\n     */\r\n    get scrolledOffset() {\r\n        return {\r\n            top: this.element.scrollTop,\r\n            left: this.element.scrollLeft\r\n        };\r\n    }\r\n    /**\r\n     * register to scroll event on html node\r\n     */\r\n    registerEvents() {\r\n        this.zone.runOutsideAngular(() => {\r\n            this.scroll$.subscribe(() => {\r\n                if (!this.viewPortController.disabled) {\r\n                    this.scrolled$.next();\r\n                    return;\r\n                }\r\n                this.scrollTo({ left: 0, top: 0 });\r\n            });\r\n        });\r\n    }\r\n}\n\nvar CHANGE_DETECTION_STRATEGY;\r\n(function (CHANGE_DETECTION_STRATEGY) {\r\n    CHANGE_DETECTION_STRATEGY[\"CHECKED\"] = \"checked\";\r\n    CHANGE_DETECTION_STRATEGY[\"INPUT\"] = \"input\";\r\n    CHANGE_DETECTION_STRATEGY[\"MUTATION\"] = \"mutation\";\r\n})(CHANGE_DETECTION_STRATEGY || (CHANGE_DETECTION_STRATEGY = {}));\r\n/**\r\n * directive for html elements\r\n * this will wrap the html element into HtmlViewport\r\n */\r\nclass NgxCustomScrollbarScrollableDirective {\r\n    constructor(viewportControl, zone, el, renderer) {\r\n        this.viewportControl = viewportControl;\r\n        this.zone = zone;\r\n        this.el = el;\r\n        this.renderer = renderer;\r\n        this.update$ = new Subject();\r\n        this.changeDetection = CHANGE_DETECTION_STRATEGY.CHECKED;\r\n        this.destroyed$ = new Subject();\r\n        this.oldScrollDimension = null;\r\n    }\r\n    set changeDetectionStrategy(strategy) {\r\n        if (strategy) {\r\n            this.changeDetection = strategy;\r\n        }\r\n    }\r\n    ngOnInit() {\r\n        this.renderer.addClass(this.el.nativeElement, \"ngx-customscrollbar--html-viewport\");\r\n        this.update$.pipe(distinctUntilChanged(), delay(100), filter((newSize) => {\r\n            const hasChanged = JSON.stringify(newSize) !== JSON.stringify(this.scrollSize);\r\n            this.scrollSize = newSize;\r\n            return hasChanged;\r\n        }), takeUntil$1(this.destroyed$)).subscribe({\r\n            next: () => this.viewportControl.update()\r\n        });\r\n        switch (this.changeDetection) {\r\n            case CHANGE_DETECTION_STRATEGY.INPUT:\r\n                this.initInputChangeDetection();\r\n                break;\r\n        }\r\n    }\r\n    ngAfterViewChecked() {\r\n        if (this.changeDetection === CHANGE_DETECTION_STRATEGY.CHECKED) {\r\n            const newScrollDimension = this.getScrollDimension();\r\n            if (this.oldScrollDimension && JSON.stringify(this.oldScrollDimension) === JSON.stringify(newScrollDimension)) {\r\n                return;\r\n            }\r\n            this.oldScrollDimension = newScrollDimension;\r\n            this.update$.next(newScrollDimension);\r\n        }\r\n    }\r\n    /**\r\n     * if component gets destroyed tell our control we gets destroyed\r\n     * and remove from dom mutations\r\n     *\r\n     * @memberof ScrollableContainerDirective\r\n     */\r\n    ngOnDestroy() {\r\n        this.htmlViewport.destroy();\r\n        this.viewportControl = null;\r\n        this.update$.complete();\r\n        this.update$ = null;\r\n        this.destroyed$.next(true);\r\n        this.destroyed$.complete();\r\n        this.destroyed$ = null;\r\n    }\r\n    /**\r\n     * start watching the dom after view has been initialized\r\n     * this ensures initial data has allready been set.\r\n     *\r\n     * We only want to know if we add or remove some items\r\n     *\r\n     * @memberof ScrollableContainerDirective\r\n     */\r\n    ngAfterViewInit() {\r\n        this.scrollSize = this.getScrollDimension();\r\n        this.htmlViewport = new HtmlViewport(this.zone, this.el.nativeElement);\r\n        this.viewportControl.viewPort = this.htmlViewport;\r\n    }\r\n    /**\r\n     * get scroll dimensions\r\n     */\r\n    getScrollDimension() {\r\n        return {\r\n            scrollHeight: this.el.nativeElement.scrollHeight,\r\n            scrollWidth: this.el.nativeElement.scrollWidth\r\n        };\r\n    }\r\n    initInputChangeDetection() {\r\n        fromEvent(this.el.nativeElement, \"input\")\r\n            .pipe(takeUntil$1(this.destroyed$))\r\n            .subscribe({\r\n            next: () => this.update$.next(this.getScrollDimension())\r\n        });\r\n    }\r\n}\r\n/** @nocollapse */ NgxCustomScrollbarScrollableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarScrollableDirective, deps: [{ token: ViewportControl, host: true }, { token: i0.NgZone }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });\r\n/** @nocollapse */ NgxCustomScrollbarScrollableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.6\", type: NgxCustomScrollbarScrollableDirective, selector: \"[ngxCustomScrollbarScrollable]\", inputs: { changeDetectionStrategy: [\"ngxCustomScrollbarScrollable\", \"changeDetectionStrategy\"] }, exportAs: [\"ngxCustomScrollbarHTMLViewport\"], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarScrollableDirective, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: \"[ngxCustomScrollbarScrollable]\",\r\n                    exportAs: \"ngxCustomScrollbarHTMLViewport\"\r\n                }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: ViewportControl, decorators: [{\r\n                        type: Host\r\n                    }] }, { type: i0.NgZone }, { type: i0.ElementRef }, { type: i0.Renderer2 }];\r\n    }, propDecorators: { changeDetectionStrategy: [{\r\n                type: Input,\r\n                args: [\"ngxCustomScrollbarScrollable\"]\r\n            }] } });\n\nclass Overflow {\r\n}\r\nOverflow.NONE = \"none\";\r\nOverflow.AUTO = \"auto\";\r\nOverflow.SCROLL = \"scroll\";\n\n/**\r\n * remove component if we dont need to scroll anymore, and\r\n * show it again if we can scroll. Same as css overflow: auto\r\n */\r\nclass NgxCustomScrollbarOverflow {\r\n    constructor(\r\n    /** The view container to add items to. */\r\n    viewContainerRef, \r\n    /** The template to use when stamping out new items. */\r\n    template, \r\n    /** viewport control to bound */\r\n    viewportController, changeDetector) {\r\n        this.viewContainerRef = viewContainerRef;\r\n        this.template = template;\r\n        this.viewportController = viewportController;\r\n        this.changeDetector = changeDetector;\r\n        this.overflow = Overflow.SCROLL;\r\n        this.isViewportVisible = false;\r\n        this.needsUpdate = false;\r\n        this.destroyed$ = new Subject();\r\n    }\r\n    /**\r\n     * angular change detection hook\r\n     */\r\n    ngDoCheck() {\r\n        if (this.needsUpdate) {\r\n            this.toggleScrollbar();\r\n        }\r\n        this.needsUpdate = false;\r\n    }\r\n    /**\r\n     * scrollbar gets destroyed\r\n     */\r\n    ngOnDestroy() {\r\n        this.destroyed$.next(true);\r\n    }\r\n    /**\r\n     * register on viewportControl onUpdate event\r\n     * and check scrollbar for visibility\r\n     */\r\n    ngOnInit() {\r\n        this.viewportController.onLoad().pipe(tap(() => this.checkScrollbarNeedsUpdate()), switchMap(() => this.viewportController.onUpdate()), takeUntil$1(this.destroyed$)).subscribe((updateEvent) => {\r\n            const event = updateEvent.type;\r\n            const checkUpdate = event === \"viewport_update\" /* UPDATE */;\r\n            if (checkUpdate) {\r\n                this.checkScrollbarNeedsUpdate();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * check for updates on scrollbar\r\n     */\r\n    checkScrollbarNeedsUpdate() {\r\n        let isOverflow;\r\n        switch (this.overflow) {\r\n            case Overflow.NONE:\r\n                isOverflow = false;\r\n                break;\r\n            case Overflow.SCROLL:\r\n                isOverflow = true;\r\n                break;\r\n            default: isOverflow = this.hasOverflow(this.viewportController.viewportDimension);\r\n        }\r\n        this.needsUpdate = isOverflow !== this.isViewportVisible;\r\n        this.isViewportVisible = isOverflow;\r\n        if (this.needsUpdate) {\r\n            this.changeDetector.detectChanges();\r\n        }\r\n    }\r\n    /**\r\n     * toggle scrollbar visibility, clears viewport\r\n     * if scrollbar should be hidden now\r\n     */\r\n    toggleScrollbar() {\r\n        if (this.isViewportVisible) {\r\n            this.viewContainerRef.createEmbeddedView(this.template);\r\n        }\r\n        else {\r\n            this.viewContainerRef.clear();\r\n        }\r\n    }\r\n}\r\n/** @nocollapse */ NgxCustomScrollbarOverflow.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarOverflow, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: ViewportControl, host: true }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });\r\n/** @nocollapse */ NgxCustomScrollbarOverflow.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.6\", type: NgxCustomScrollbarOverflow, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarOverflow, decorators: [{\r\n            type: Directive\r\n        }], ctorParameters: function () {\r\n        return [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: ViewportControl, decorators: [{\r\n                        type: Host\r\n                    }] }, { type: i0.ChangeDetectorRef }];\r\n    } });\n\n/**\r\n * remove component if no overflow on y axis\r\n */\r\nclass NgxCustomScrollbarOverflowYDirective extends NgxCustomScrollbarOverflow {\r\n    set ngxCustomScrollbarOverflowY(overflow) {\r\n        if (overflow === Overflow.NONE) {\r\n            this.viewportController.disableScroll(true);\r\n        }\r\n        this.overflow = overflow;\r\n    }\r\n    hasOverflow(viewportDimension) {\r\n        return viewportDimension.scrollHeight > viewportDimension.height;\r\n    }\r\n}\r\n/** @nocollapse */ NgxCustomScrollbarOverflowYDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarOverflowYDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });\r\n/** @nocollapse */ NgxCustomScrollbarOverflowYDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.6\", type: NgxCustomScrollbarOverflowYDirective, selector: \"[ngxCustomScrollbarOverflowY]\", inputs: { ngxCustomScrollbarOverflowY: \"ngxCustomScrollbarOverflowY\" }, usesInheritance: true, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarOverflowYDirective, decorators: [{\r\n            type: Directive,\r\n            args: [{ selector: \"[ngxCustomScrollbarOverflowY]\" }]\r\n        }], propDecorators: { ngxCustomScrollbarOverflowY: [{\r\n                type: Input\r\n            }] } });\n\n/**\r\n * renders component only if the viewport is overflows in x axis\r\n * otherwise remove / dont render it\r\n */\r\nclass NgxCustomScrollbarOverflowXDirective extends NgxCustomScrollbarOverflow {\r\n    set ngxCustomScrollbarOverflowX(overflow) {\r\n        this.overflow = overflow;\r\n    }\r\n    hasOverflow(viewportDimension) {\r\n        return viewportDimension.scrollWidth > viewportDimension.width;\r\n    }\r\n}\r\n/** @nocollapse */ NgxCustomScrollbarOverflowXDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarOverflowXDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });\r\n/** @nocollapse */ NgxCustomScrollbarOverflowXDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.6\", type: NgxCustomScrollbarOverflowXDirective, selector: \"[ngxCustomScrollbarOverflowX]\", inputs: { ngxCustomScrollbarOverflowX: \"ngxCustomScrollbarOverflowX\" }, usesInheritance: true, ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarOverflowXDirective, decorators: [{\r\n            type: Directive,\r\n            args: [{ selector: \"[ngxCustomScrollbarOverflowX]\" }]\r\n        }], propDecorators: { ngxCustomScrollbarOverflowX: [{\r\n                type: Input\r\n            }] } });\n\nclass NgxCustomScrollbarModule {\r\n}\r\n/** @nocollapse */ NgxCustomScrollbarModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\n/** @nocollapse */ NgxCustomScrollbarModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarModule, declarations: [NgxCustomScrollbarComponent,\r\n        NgxCustomScrollbarHideOnNativeStyleDirective,\r\n        NgxCustomScrollbarOverflowXDirective,\r\n        NgxCustomScrollbarOverflowYDirective,\r\n        NgxCustomScrollbarScrollableDirective], imports: [CommonModule], exports: [NgxCustomScrollbarComponent,\r\n        NgxCustomScrollbarHideOnNativeStyleDirective,\r\n        NgxCustomScrollbarOverflowXDirective,\r\n        NgxCustomScrollbarOverflowYDirective,\r\n        NgxCustomScrollbarScrollableDirective] });\r\n/** @nocollapse */ NgxCustomScrollbarModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarModule, providers: [\r\n        ViewportControl\r\n    ], imports: [[\r\n            CommonModule,\r\n        ]] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.6\", ngImport: i0, type: NgxCustomScrollbarModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    declarations: [\r\n                        NgxCustomScrollbarComponent,\r\n                        NgxCustomScrollbarHideOnNativeStyleDirective,\r\n                        NgxCustomScrollbarOverflowXDirective,\r\n                        NgxCustomScrollbarOverflowYDirective,\r\n                        NgxCustomScrollbarScrollableDirective,\r\n                    ],\r\n                    exports: [\r\n                        NgxCustomScrollbarComponent,\r\n                        NgxCustomScrollbarHideOnNativeStyleDirective,\r\n                        NgxCustomScrollbarOverflowXDirective,\r\n                        NgxCustomScrollbarOverflowYDirective,\r\n                        NgxCustomScrollbarScrollableDirective,\r\n                    ],\r\n                    imports: [\r\n                        CommonModule,\r\n                    ],\r\n                    providers: [\r\n                        ViewportControl\r\n                    ]\r\n                }]\r\n        }] });\n\n/*\r\n * Public API Surface of scrollbars\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { DomHelper, NgxCustomScrollbarComponent, NgxCustomScrollbarHideOnNativeStyleDirective, NgxCustomScrollbarModule, NgxCustomScrollbarOverflowXDirective, NgxCustomScrollbarOverflowYDirective, NgxCustomScrollbarScrollableDirective, Overflow, Viewport, ViewportControl, WindowResize };\n//# sourceMappingURL=ngx-customscrollbar.mjs.map\n","map":{"version":3,"file":"ngx-customscrollbar.mjs","sources":["../../../lib/ngx-customscrollbars/helper/dom.helper.ts","../../../lib/ngx-customscrollbars/helper/import-data.decorator.ts","../../../lib/ngx-customscrollbars/model/container-measure.model.ts","../../../lib/ngx-customscrollbars/provider/scroll.helper.ts","../../../lib/ngx-customscrollbars/provider/horiziontal-scroll.helper.ts","../../../lib/ngx-customscrollbars/provider/vertical-scroll.helper.ts","../../../lib/ngx-customscrollbars/model/scroll-container-measure.model.ts","../../../lib/ngx-customscrollbars/provider/window-resize.ts","../../../lib/ngx-customscrollbars/provider/viewport.control.ts","../../../lib/ngx-customscrollbars/components/scrollbar.component.ts","../../../lib/ngx-customscrollbars/components/scrollbar.component.html","../../../lib/ngx-customscrollbars/directives/no-native-style.directive.ts","../../../lib/ngx-customscrollbars/viewport/viewport.ts","../../../lib/ngx-customscrollbars/viewport/html.viewport.ts","../../../lib/ngx-customscrollbars/directives/scrollable-container.directive.ts","../../../lib/ngx-customscrollbars/model/overflow.ts","../../../lib/ngx-customscrollbars/directives/overflow-auto.ts","../../../lib/ngx-customscrollbars/directives/overflow-y.directive.ts","../../../lib/ngx-customscrollbars/directives/overflow-x.directive.ts","../../../lib/ngx-customscrollbars/custom-scrollbars.module.ts","../../../lib/public_api.ts","../../../lib/ngx-customscrollbar.ts"],"sourcesContent":["import { Scrollbar } from \"../api/scrollbar.interface\";\r\n\r\nexport namespace DomHelper {\r\n\r\n    export interface IElementMeasure {\r\n        innerHeight: number;\r\n        innerWidth: number;\r\n        height: number;\r\n        width: number;\r\n        top: number;\r\n        left: number;\r\n    }\r\n\r\n    export interface IScrollContainerMeasure extends IElementMeasure {\r\n        scrollHeight: number;\r\n        scrollLeft: number;\r\n        scrollTop: number;\r\n        scrollWidth: number;\r\n    }\r\n\r\n    /**\r\n     * get computed style from element\r\n     */\r\n    export function getElementStyle(el: HTMLElement, style: string): string | null {\r\n        let styleValue: string;\r\n        try {\r\n            styleValue = getComputedStyle(el, null).getPropertyValue(style);\r\n        } catch (e) {\r\n            styleValue = null;\r\n        }\r\n        return styleValue;\r\n    }\r\n\r\n    export function getMeasure(el: HTMLElement): DomHelper.IElementMeasure {\r\n        // get computed style not works that good and that fast like el.offsetHeight\r\n        return {\r\n            height: el.offsetHeight,\r\n            width: el.offsetWidth,\r\n            innerHeight: getInnerHeight(el),\r\n            innerWidth: getInnerWidth(el),\r\n            top: el.offsetTop,\r\n            left: el.offsetLeft\r\n        };\r\n    }\r\n\r\n    export function getScrollContainerMeasure(el: HTMLElement): DomHelper.IScrollContainerMeasure {\r\n        const elMeasure = getMeasure(el);\r\n        return {\r\n            ...elMeasure,\r\n            scrollHeight: el.scrollHeight,\r\n            scrollLeft: el.scrollLeft,\r\n            scrollTop: el.scrollTop,\r\n            scrollWidth: el.scrollWidth,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * get element inner height, without padding\r\n     */\r\n    export function getInnerHeight(el: HTMLElement): number {\r\n        /** @todo this will called alot times on resize */\r\n        const computed = getComputedStyle(el, null);\r\n        const paddingTop = parseInt(computed.getPropertyValue(\"padding-top\"), 10);\r\n        const paddingBot = parseInt(computed.getPropertyValue(\"padding-bottom\"), 10);\r\n        return el.offsetHeight - paddingTop - paddingBot;\r\n    }\r\n\r\n    /**\r\n     * get elment inner width without border, margin and padding\r\n     */\r\n    export function getInnerWidth(el: HTMLElement): number {\r\n        /** @todo this will called alot times on resize */\r\n        const computed = getComputedStyle(el, null);\r\n        const paddingLeft = parseInt(computed.getPropertyValue(\"padding-left\"), 10);\r\n        const paddingRight = parseInt(computed.getPropertyValue(\"padding-right\"), 10);\r\n        return el.offsetWidth - paddingLeft - paddingRight;\r\n    }\r\n\r\n    /**\r\n     * get element bounds\r\n     */\r\n    export function getElementBounds(el: HTMLElement): ClientRect {\r\n        return el.getBoundingClientRect();\r\n    }\r\n\r\n    /**\r\n     * calclulate offsetX / offsetY for MouseEvents\r\n     * we could use event.offsetX or event.offsetY but this is experimental\r\n     * and not working correctly in FF for some times.\r\n     */\r\n    export function getMouseOffset(event: MouseEvent): Scrollbar.IOffset {\r\n        const rect = (event.currentTarget as HTMLElement).getBoundingClientRect();\r\n        return {\r\n            left: event.clientX - rect.left,\r\n            top: event.clientY - rect.top\r\n        };\r\n    }\r\n}\r\n","\r\nexport function importData<T>(target, key = null, descriptor: PropertyDescriptor): PropertyDescriptor {\r\n\r\n    if (!descriptor) {\r\n        descriptor = Object.getOwnPropertyDescriptor(target, key);\r\n    }\r\n\r\n    const originalMethod = descriptor.value;\r\n    descriptor.value = function (data: T) {\r\n        // get all properties, exclude decorated property\r\n        Object.keys(data).forEach((property) => {\r\n            this[property] = data[property];\r\n        });\r\n        // call original descriptor\r\n        const result = originalMethod.call(this, data);\r\n        return result;\r\n    };\r\n    return descriptor;\r\n}\r\n","\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { importData } from \"../helper/import-data.decorator\";\r\n\r\n/**\r\n * viewport model so save / share current state from viewport\r\n */\r\nexport class ContainerMeasureModel<T> implements DomHelper.IElementMeasure {\r\n\r\n    private _measure: T;\r\n\r\n    private _innerHeight: number;\r\n\r\n    private _innerWidth: number;\r\n\r\n    private _height: number;\r\n\r\n    private _width: number;\r\n\r\n    private _top: number;\r\n\r\n    private _left: number;\r\n\r\n    public constructor(data: T) {\r\n        this.setMeasures(data);\r\n    }\r\n\r\n    @importData\r\n    public setMeasures(data: T) {\r\n        this._measure = data;\r\n    }\r\n\r\n    public get measures(): T {\r\n        return {...this._measure};\r\n    }\r\n\r\n    public set innerHeight(value: number) {\r\n        this._innerHeight = value;\r\n    }\r\n\r\n    public set innerWidth(value: number) {\r\n        this._innerWidth = value;\r\n    }\r\n\r\n    public set height(value: number) {\r\n        this._height = value;\r\n    }\r\n\r\n    public set width(value: number) {\r\n        this._width = value;\r\n    }\r\n\r\n    public set top(value: number) {\r\n        this._top = value;\r\n    }\r\n\r\n    public set left(value: number) {\r\n        this._left = value;\r\n    }\r\n\r\n    public get innerHeight(): number {\r\n        return this._innerHeight;\r\n    }\r\n\r\n    /**\r\n     * @returns number\r\n     */\r\n    public get innerWidth(): number {\r\n        return this._innerWidth;\r\n    }\r\n\r\n    public get height(): number {\r\n        return this._height;\r\n    }\r\n\r\n    public get width(): number {\r\n        return this._width;\r\n    }\r\n\r\n    public get top(): number {\r\n        return this._top;\r\n    }\r\n\r\n    public get left(): number {\r\n        return this._left;\r\n    }\r\n}\r\n","import { Scrollbar } from \"../api/scrollbar.interface\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\n\r\nexport abstract class ScrollHelper {\r\n\r\n    public constructor(\r\n        protected thumbMeasure: DomHelper.IElementMeasure,\r\n        protected trackMeasure: DomHelper.IElementMeasure,\r\n        protected _viewportMeasure: DomHelper.IScrollContainerMeasure\r\n    ) { }\r\n\r\n    public set viewportMeasure(measure: DomHelper.IScrollContainerMeasure) {\r\n        this._viewportMeasure = measure;\r\n    }\r\n\r\n    public get viewportMeasure(): DomHelper.IScrollContainerMeasure {\r\n        return this._viewportMeasure;\r\n    }\r\n\r\n    /**\r\n     * returns thumb transform property\r\n     */\r\n    public abstract getScrollThumbCssTransform(): any;\r\n\r\n    public abstract calculateDragDropScrollOffset(\r\n        dragMove: MouseEvent,\r\n        dragStart: Scrollbar.IOffset,\r\n        offset: ClientRect\r\n    ): Scrollbar.IOffset;\r\n\r\n    public abstract calculateScrollMax(): number;\r\n\r\n    public abstract calculateTrackMax(): number;\r\n\r\n    public abstract calculateThumbSize(): number;\r\n\r\n    public abstract calculateThumbPosition(): number;\r\n\r\n    public abstract getScrollThumbCssSize(): any;\r\n\r\n    public abstract isScrollable(): boolean;\r\n\r\n    /**\r\n     * return calculated page scroll offset for specific axis\r\n     */\r\n    public abstract calculatePageScroll(offset: Scrollbar.IOffset): Scrollbar.IOffset;\r\n\r\n    /**\r\n     * return true if we could skip scroll event otherwise false\r\n     */\r\n    public couldSkipScrollEvent(direction: Scrollbar.DIRECTION, event: Scrollbar.ScrollEvent): boolean {\r\n\r\n        if (direction === Scrollbar.DIRECTION.Y && event.scrolledY) {\r\n            return false;\r\n        }\r\n\r\n        if (direction === Scrollbar.DIRECTION.X && event.scrolledX) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n","import { ScrollHelper } from \"./scroll.helper\";\r\nimport { Scrollbar } from \"../api/scrollbar.interface\";\r\n\r\n/**\r\n * helper for calculations on vertical scrollbars\r\n */\r\nexport class HorizontalScrollHelper extends ScrollHelper {\r\n\r\n    public calculateScrollMax(): number {\r\n        return this.viewportMeasure.scrollWidth - this.viewportMeasure.width;\r\n    }\r\n\r\n    public calculateThumbPosition(): number {\r\n        const left = this.viewportMeasure.scrollLeft;\r\n        const offsetLeft = left * this.calculateTrackMax() / this.calculateScrollMax();\r\n        this.thumbMeasure.left = offsetLeft;\r\n        return offsetLeft;\r\n    }\r\n\r\n    public calculateDragDropScrollOffset(dragMove: MouseEvent, dragDroffset: Scrollbar.IOffset, offset: ClientRect) {\r\n        const offsetLeft = dragMove.clientX - offset.left;\r\n        const trackMax = this.calculateTrackMax();\r\n        const scrollMax = this.calculateScrollMax();\r\n\r\n        const top = this.viewportMeasure.scrollTop;\r\n        const left = scrollMax * (offsetLeft - dragDroffset.left) / trackMax;\r\n\r\n        return {top, left};\r\n    }\r\n\r\n    public calculateTrackMax(): number {\r\n        return this.trackMeasure.innerWidth - this.calculateThumbSize();\r\n    }\r\n\r\n    public calculateThumbSize(): number {\r\n        const thumbSize = this.viewportMeasure.width * this.trackMeasure.innerWidth / this.viewportMeasure.scrollWidth;\r\n        return thumbSize < 20 ? 20 : thumbSize;\r\n    }\r\n\r\n    /**\r\n     * returns thumb transform property\r\n     */\r\n    public getScrollThumbCssTransform(): any {\r\n        const left = this.calculateThumbPosition();\r\n\r\n        return {\r\n            style: \"transform\",\r\n            value: `translate3d(${left}px, 0, 0)`\r\n        };\r\n    }\r\n\r\n    public getScrollThumbCssSize() {\r\n        const width = this.calculateThumbSize();\r\n        return { style: \"width\", value: `${width}px` };\r\n    }\r\n\r\n    public isScrollable(): boolean {\r\n        return this.viewportMeasure.scrollWidth > this.viewportMeasure.width;\r\n    }\r\n\r\n    public calculatePageScroll(offset: Scrollbar.IOffset): Scrollbar.IOffset {\r\n\r\n        const modifier = offset.left < this.thumbMeasure.left\r\n            ? Scrollbar.PAGE_SCROLL.BACK\r\n            : Scrollbar.PAGE_SCROLL.FORWARD;\r\n\r\n        const scrollOffset = {\r\n            left: this.viewportMeasure.scrollLeft + (this.viewportMeasure.width * modifier),\r\n            top: this.viewportMeasure.scrollTop\r\n        };\r\n\r\n        return scrollOffset;\r\n    }\r\n}\r\n","import { ScrollHelper } from \"./scroll.helper\";\r\nimport { Scrollbar } from \"../api/scrollbar.interface\";\r\n\r\nexport class VerticalScrollHelper extends ScrollHelper {\r\n\r\n    /**\r\n     * calculate offset we have scrolled on viewport\r\n     */\r\n    public calculateDragDropScrollOffset(dragMove: MouseEvent, dragStartOffset: Scrollbar.IOffset, offset: ClientRect): Scrollbar.IOffset {\r\n\r\n        const offsetTop = dragMove.clientY - offset.top;\r\n        /** @TODO dont calculate this every time, this will not change on drag drop */\r\n        const trackMax = this.calculateTrackMax();\r\n        /** @TODO dont calculate this every time, this will not change on drag drop */\r\n        const scrollMax = this.calculateScrollMax();\r\n\r\n        const top = scrollMax * (offsetTop - dragStartOffset.top) / trackMax;\r\n        const left = this.viewportMeasure.scrollLeft;\r\n\r\n        return { top, left };\r\n    }\r\n\r\n    /**\r\n     * calculate max scroll position on viewport\r\n     */\r\n    public calculateScrollMax(): number {\r\n        return this.viewportMeasure.scrollHeight - this.viewportMeasure.height;\r\n    }\r\n\r\n    /**\r\n     * calculate max track position for scrollThumb\r\n     */\r\n    public calculateTrackMax(): number {\r\n        return this.trackMeasure.innerHeight - this.calculateThumbSize();\r\n    }\r\n\r\n    /**\r\n     * calculate thumbnail size\r\n     */\r\n    public calculateThumbSize(): number {\r\n        const thumbSize = this.viewportMeasure.height * this.trackMeasure.innerHeight / this.viewportMeasure.scrollHeight;\r\n        return thumbSize < 20 ? 20 : thumbSize;\r\n    }\r\n\r\n    /**\r\n     * calculate scrollthumb position, set position for thumb\r\n     */\r\n    public calculateThumbPosition(): number {\r\n        const top = this.viewportMeasure.scrollTop;\r\n        const valueTop = top * this.calculateTrackMax() / this.calculateScrollMax();\r\n        this.thumbMeasure.top = valueTop;\r\n        return valueTop;\r\n    }\r\n\r\n    /**\r\n     * returns thumb transform property\r\n     */\r\n    public getScrollThumbCssTransform(): any {\r\n        const top = this.calculateThumbPosition();\r\n        return {\r\n            style: \"transform\",\r\n            value: `translate3d(0, ${top}px, 0)`\r\n        };\r\n    }\r\n\r\n    public getScrollThumbCssSize(): any {\r\n        const height = this.calculateThumbSize();\r\n        return { style: \"height\", value: `${height}px` };\r\n    }\r\n\r\n    public isScrollable(): boolean {\r\n        return this.viewportMeasure.scrollHeight > this.viewportMeasure.height;\r\n    }\r\n\r\n    public calculatePageScroll(offset: Scrollbar.IOffset): Scrollbar.IOffset {\r\n\r\n        const modifier = offset.top < this.thumbMeasure.top\r\n            ? Scrollbar.PAGE_SCROLL.BACK\r\n            : Scrollbar.PAGE_SCROLL.FORWARD;\r\n\r\n        const scrollOffset = {\r\n            top: this.viewportMeasure.scrollTop + (this.viewportMeasure.height * modifier),\r\n            left: this.viewportMeasure.scrollLeft\r\n        };\r\n\r\n        return scrollOffset;\r\n    }\r\n}\r\n","import { ContainerMeasureModel } from \"./container-measure.model\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { importData } from \"../helper/import-data.decorator\";\r\n\r\nexport class ScrollContainerMeasureModel extends ContainerMeasureModel<DomHelper.IScrollContainerMeasure> {\r\n\r\n    /**\r\n     * available scroll height for viewport\r\n     */\r\n    private _scrollHeight: number;\r\n\r\n    /**\r\n     * scroll offset left\r\n     */\r\n    private _scrollLeft: number;\r\n\r\n    /**\r\n     * scroll offset top\r\n     */\r\n    private _scrollTop: number;\r\n\r\n    /**\r\n     * available scroll width for viewport\r\n     */\r\n    private _scrollWidth: number;\r\n\r\n    /**\r\n     * set measure data automatically imports data\r\n     * to model\r\n     */\r\n    @importData\r\n    public setMeasures(data: DomHelper.IScrollContainerMeasure) {\r\n        super.setMeasures(data);\r\n    }\r\n\r\n    public set scrollHeight(value: number) {\r\n        this._scrollHeight = value;\r\n    }\r\n\r\n    public set scrollLeft(value: number) {\r\n        this._scrollLeft = value;\r\n    }\r\n\r\n    public set scrollTop(value: number) {\r\n        this._scrollTop = value;\r\n    }\r\n\r\n    public set scrollWidth(value: number) {\r\n        this._scrollWidth = value;\r\n    }\r\n\r\n    public get scrollHeight(): number {\r\n        return this._scrollHeight;\r\n    }\r\n\r\n    public get scrollLeft(): number {\r\n        return this._scrollLeft;\r\n    }\r\n\r\n    public get scrollTop(): number {\r\n        return this._scrollTop;\r\n    }\r\n\r\n    public get scrollWidth(): number {\r\n        return this._scrollWidth;\r\n    }\r\n}\r\n","import { Injectable, NgZone } from \"@angular/core\";\r\nimport { Observable, Subject, fromEvent, Subscription, OperatorFunction } from \"rxjs\";\r\n\r\n/**\r\n *\r\n */\r\n@Injectable({ providedIn: \"root\" })\r\nexport class WindowResize {\r\n\r\n    /**\r\n     * window resize event stream\r\n     */\r\n    private windowResize$: Observable<Event>;\r\n\r\n    /**\r\n     * shared stream which one is registered on windowResize Stream\r\n     * all others will subscribe to shared stream so we can ensure\r\n     * only one window resize event exists\r\n     */\r\n    private shared$: Subject<any>;\r\n\r\n    /**\r\n     * current subscriber count on shared stream, the first subscriber\r\n     * will trigger shared stream registration on window resize stream\r\n     * if all subscribers are removed we automatically remove from\r\n     */\r\n    private subscriberCount = 0;\r\n\r\n    /**\r\n     * the subscription to window resize stream\r\n     * will be canceled if no one gets interrested anymore\r\n     */\r\n    private resizeSubscription: Subscription;\r\n\r\n    constructor(\r\n        private zone: NgZone\r\n    ) {\r\n        this.windowResize$ = fromEvent(window, \"resize\");\r\n        this.shared$ = new Subject();\r\n    }\r\n\r\n    /**\r\n     * create shared event stream and register to this\r\n     */\r\n    public onChange(): Observable<void> {\r\n        // subscribe\r\n        return Observable.create(observer => {\r\n            this.subscriberCount++;\r\n            const event$ = this.shared$.subscribe(observer);\r\n\r\n            if (this.subscriberCount === 1) {\r\n                this.subscribeToWindowResizeEvent();\r\n            }\r\n\r\n            // unsubscribe\r\n            return () => {\r\n                event$.unsubscribe();\r\n                this.subscriberCount--;\r\n                if (this.subscriberCount <= 0) {\r\n                    this.resizeSubscription.unsubscribe();\r\n                }\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * register to window resize events\r\n     */\r\n    private subscribeToWindowResizeEvent(): void {\r\n        this.zone.runOutsideAngular(() => {\r\n            this.resizeSubscription = this.windowResize$\r\n                .pipe(debounceAnimationFrame())\r\n                .subscribe(() => this.shared$.next());\r\n        });\r\n    }\r\n}\r\n\r\nfunction debounceAnimationFrame<T>(): OperatorFunction<T, T> {\r\n\r\n    return function (source$: Observable<T>): Observable<T> {\r\n\r\n        let resizeFired = false;\r\n        let drawing = false;\r\n\r\n        const requestAnimationFrame = window.requestAnimationFrame || (window as any).webkitRequestAnimationFrame;\r\n\r\n        const obs = new Observable<T>((observer) => {\r\n            function drawResize(): void {\r\n                if (resizeFired === true) {\r\n                    resizeFired = false;\r\n                    requestAnimationFrame(() => {\r\n                        observer.next();\r\n                        drawResize();\r\n                    });\r\n                } else {\r\n                    drawing = false;\r\n                }\r\n            }\r\n\r\n            source$.subscribe(() => {\r\n                if (drawing === false) {\r\n                    resizeFired = true;\r\n                    drawResize();\r\n                }\r\n            });\r\n        });\r\n        return obs;\r\n    };\r\n}\r\n","import { Injectable, OnDestroy } from \"@angular/core\";\r\nimport { Observable, ReplaySubject, Subject, Subscription } from \"rxjs\";\r\nimport { takeUntil } from \"rxjs/internal/operators/takeUntil\";\r\nimport { Scrollbar } from \"../api/scrollbar.interface\";\r\nimport { WindowResize } from \"./window-resize\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { ScrollContainerMeasureModel } from \"../model/scroll-container-measure.model\";\r\nimport { NgxCustomScrollbarComponent } from \"../components/scrollbar.component\";\r\n\r\n/**\r\n * viewport contol service, the glue between scrollbars and the viewport\r\n */\r\n@Injectable()\r\nexport class ViewportControl implements OnDestroy {\r\n\r\n    private viewportUpdate$: Subject<Scrollbar.Event>;\r\n\r\n    private viewportReady$: ReplaySubject<ScrollContainerMeasureModel>;\r\n\r\n    private viewportScroll$: Subject<Scrollbar.ScrollEvent>;\r\n\r\n    private destroy$: Subject<boolean> = new Subject();\r\n\r\n    private scrollSub: Subscription;\r\n\r\n    private scrollbars: Set<NgxCustomScrollbarComponent> = new Set();\r\n\r\n    private scrollbarViewPort: Scrollbar.IScrollbarViewport;\r\n    private scrollPosition = {\r\n        vertical: 0,\r\n        horizontal: 0\r\n    };\r\n\r\n    private viewportModel: ScrollContainerMeasureModel;\r\n\r\n    private _disabled: boolean;\r\n\r\n    public constructor(\r\n        private resize: WindowResize\r\n    ) {\r\n        this.viewportUpdate$ = new Subject();\r\n        this.viewportReady$ = new ReplaySubject(1);\r\n        this.viewportScroll$ = new Subject();\r\n\r\n        this.registerEvents();\r\n    }\r\n\r\n    /**\r\n     * inject the viewport which should be scrolled\r\n     */\r\n    public set viewPort(viewPort: Scrollbar.IScrollbarViewport) {\r\n\r\n        if (this.scrollbarViewPort && this.scrollbarViewPort === viewPort) {\r\n            return;\r\n        }\r\n\r\n        if (this.scrollSub) {\r\n            this.scrollSub.unsubscribe();\r\n        }\r\n\r\n        this.scrollbarViewPort = viewPort;\r\n        this.scrollSub = this.scrollbarViewPort.onScrolled()\r\n            .pipe(takeUntil(this.destroy$))\r\n            .subscribe(() => {\r\n                this.onScrolled();\r\n            });\r\n\r\n        this.scrollbarViewPort.control = this;\r\n\r\n        /** create new viewport model if a viewport has been bound */\r\n        this.viewportModel = new ScrollContainerMeasureModel(this.scrollbarViewPort.measureSize());\r\n        this.viewportReady$.next(this.viewportModel);\r\n\r\n        this.scrollbarViewPort.init();\r\n    }\r\n\r\n    /**\r\n     * register scrollbar to viewport so we could render them\r\n     * programatically if we need to do\r\n     */\r\n    public addScrollbar(scrollbar: NgxCustomScrollbarComponent) {\r\n        if (!this.scrollbars.has(scrollbar)) {\r\n            this.scrollbars.add(scrollbar);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * remove scrollbar to viewport\r\n     */\r\n    public removeScrollbar(scrollbar: NgxCustomScrollbarComponent) {\r\n        if (this.scrollbars.has(scrollbar)) {\r\n            this.scrollbars.delete(scrollbar);\r\n        }\r\n    }\r\n\r\n    public get viewportDimension(): DomHelper.IScrollContainerMeasure {\r\n        return this.viewportModel.measures;\r\n    }\r\n\r\n    public get disabled(): boolean {\r\n        return this._disabled || false;\r\n    }\r\n\r\n    /**\r\n     * scroll page by specific amount\r\n     * move this to helper\r\n     */\r\n    public scrollPage(direction: number) {\r\n        const pageSize = this.viewportDimension.height;\r\n        const scrollTop = this.viewportDimension.scrollTop + pageSize * direction;\r\n        this.scrollTo(this.sanitizeScrollPosition({ left: 0, top: scrollTop }));\r\n    }\r\n\r\n    /** not called if i just reload this */\r\n    ngOnDestroy(): void {\r\n        this.scrollbarViewPort.destroy();\r\n\r\n        this.destroy$.next(true);\r\n        this.viewportReady$.complete();\r\n        this.viewportUpdate$.complete();\r\n        this.destroy$.complete();\r\n        this.scrollbars.clear();\r\n        this.viewportModel = null;\r\n        this.scrollbars = null;\r\n    }\r\n\r\n    public onLoad(): Observable<ScrollContainerMeasureModel> {\r\n        return this.viewportReady$.asObservable();\r\n    }\r\n\r\n    public onScroll() {\r\n        return this.viewportScroll$.asObservable();\r\n    }\r\n\r\n    /**\r\n     * returns observable to get notified if viewport\r\n     * has been changed in scroll or has been refreshed\r\n     */\r\n    public onUpdate(): Observable<Scrollbar.Event | Scrollbar.ScrollEvent> {\r\n        return this.viewportUpdate$.asObservable();\r\n    }\r\n\r\n    /**\r\n     * viewport was changed, this could happen if new content, or window has been resized\r\n     * has been added or removed\r\n     */\r\n    public update() {\r\n        /** triggers soft update to trigger directives */\r\n        this.viewportModel.setMeasures(this.scrollbarViewPort.measureSize());\r\n        this.emitUpdate({ type: Scrollbar.VIEWPORT_EVENT.UPDATE });\r\n\r\n        /** get size again and trigger update for scrollbars */\r\n        this.viewportModel.setMeasures(this.scrollbarViewPort.measureSize());\r\n        this.scrollbars.forEach((scrollbar) => scrollbar.render());\r\n    }\r\n\r\n\r\n    /**\r\n     * viewport should scroll by specific amount\r\n     */\r\n    public scrollTo(scrolledTo) {\r\n        this.scrollbarViewPort.scrollTo(this.sanitizeScrollPosition(scrolledTo));\r\n    }\r\n\r\n    /**\r\n     * scroll viewport to origin\r\n     */\r\n    public reset() {\r\n        this.scrollTo({\r\n            top: 0,\r\n            left: 0\r\n        });\r\n    }\r\n\r\n    public disableScroll(disabled: boolean) {\r\n        this._disabled = disabled;\r\n    }\r\n\r\n    private registerEvents() {\r\n        this.resize.onChange()\r\n            .pipe(takeUntil(this.destroy$))\r\n            .subscribe(() => this.update());\r\n    }\r\n\r\n    /**\r\n     * viewport has been scrolled\r\n     */\r\n    private onScrolled() {\r\n\r\n        const scrolled = this.scrollbarViewPort.scrolledOffset;\r\n        const scrolledY = this.scrollPosition.vertical !== scrolled.top;\r\n        const scrolledX = this.scrollPosition.horizontal !== scrolled.left;\r\n\r\n        // update model to set current scroll offsets\r\n        this.viewportModel.scrollLeft = scrolled.left;\r\n        this.viewportModel.scrollTop = scrolled.top;\r\n\r\n        this.viewportScroll$.next({\r\n            scrolledY,\r\n            scrolledX,\r\n            type: Scrollbar.VIEWPORT_EVENT.SCROLLED\r\n        });\r\n\r\n        this.scrollPosition.vertical = scrolled.top;\r\n        this.scrollPosition.horizontal = scrolled.left;\r\n    }\r\n\r\n    /**\r\n     * emits an update event through viewportUpdate observable\r\n     */\r\n    private emitUpdate(event: Scrollbar.Event | Scrollbar.ScrollEvent) {\r\n        this.viewportUpdate$.next(event);\r\n    }\r\n\r\n    /**\r\n     * sanitize scroll position to ensure we not scroll over the bounds\r\n     */\r\n    private sanitizeScrollPosition(scrollTo: Scrollbar.IOffset) {\r\n        const scrollMaxY = this.viewportModel.scrollHeight - this.viewportModel.height;\r\n        const scrollMaxX = this.viewportModel.scrollWidth - this.viewportModel.width;\r\n        const { top, left } = scrollTo;\r\n\r\n        return {\r\n            top: top < 0 ? 0 : top > scrollMaxY ? scrollMaxY : top,\r\n            left: left < 0 ? 0 : left > scrollMaxX ? scrollMaxX : left,\r\n        };\r\n    }\r\n}\r\n","import {\r\n    AfterViewInit,\r\n    Component,\r\n    ElementRef,\r\n    Host,\r\n    Inject,\r\n    NgZone,\r\n    OnDestroy,\r\n    Renderer2,\r\n    ViewChild,\r\n    OnInit,\r\n    Input,\r\n    HostBinding,\r\n    Optional\r\n} from \"@angular/core\";\r\nimport { DOCUMENT } from \"@angular/common\";\r\nimport { fromEvent, Subject, Observable } from \"rxjs\";\r\nimport { tap, takeUntil, switchMap, finalize } from \"rxjs/operators\";\r\nimport { Scrollbar } from \"../api/scrollbar.interface\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { ContainerMeasureModel } from \"../model/container-measure.model\";\r\nimport { ScrollHelper } from \"../provider/scroll.helper\";\r\nimport { ViewportControl } from \"../provider/viewport.control\";\r\nimport { HorizontalScrollHelper } from \"../provider/horiziontal-scroll.helper\";\r\nimport { VerticalScrollHelper } from \"../provider/vertical-scroll.helper\";\r\n\r\n@Component({\r\n    selector: \"ngx-customscrollbar\",\r\n    templateUrl: \"scrollbar.component.html\",\r\n    styleUrls: [\"./scrollbar.component.scss\"]\r\n})\r\nexport class NgxCustomScrollbarComponent implements AfterViewInit, OnDestroy, OnInit {\r\n\r\n    @Input()\r\n    @HostBinding(\"class\")\r\n    @HostBinding(\"class.ngx-customscrollbars\")\r\n    public scrollDirection = Scrollbar.DIRECTION.Y;\r\n\r\n    @ViewChild(\"scrollbarTrack\", {read: ElementRef, static: true})\r\n    private scrollbarTrack: ElementRef;\r\n\r\n    @ViewChild(\"scrollbarThumb\", {read: ElementRef, static: true})\r\n    private scrollbarThumb: ElementRef;\r\n\r\n    private scrollHelper: ScrollHelper;\r\n    private isDestroyed$: Subject<boolean>;\r\n    private thumbMeasure: ContainerMeasureModel<DomHelper.IElementMeasure>;\r\n    private trackMeasure: ContainerMeasureModel<DomHelper.IElementMeasure>;\r\n    private viewportMeasure: DomHelper.IScrollContainerMeasure;\r\n\r\n    constructor(\r\n        @Host() @Optional() private viewportController: ViewportControl,\r\n        @Inject(DOCUMENT) private document,\r\n        private hostEl: ElementRef,\r\n        private ngZone: NgZone,\r\n        private renderer: Renderer2,\r\n    ) {\r\n        this.isDestroyed$ = new Subject();\r\n    }\r\n\r\n    /**\r\n     * initialize scrollbar track and scrollbar thumb events\r\n     */\r\n    ngOnInit() {\r\n\r\n        this.ngZone.runOutsideAngular(() => {\r\n            this.registerThumbEvents()\r\n                .pipe(takeUntil(this.isDestroyed$))\r\n                .subscribe();\r\n\r\n            this.registerScrollTrackEvents();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * dom is rendered and initialized\r\n     */\r\n    ngAfterViewInit() {\r\n\r\n        this.viewportController.addScrollbar(this);\r\n\r\n        /** viewport has been attached */\r\n        this.viewportController.onLoad()\r\n            .pipe(takeUntil(this.isDestroyed$))\r\n            .subscribe((measure) => this.handleViewportLoaded(measure));\r\n\r\n        /** viewport has been updated in size or is scrolled */\r\n        this.viewportController.onScroll()\r\n            .pipe(takeUntil(this.isDestroyed$))\r\n            .subscribe((event) => this.handleViewportScroll(event));\r\n    }\r\n\r\n    /**\r\n     * compoenent gets destroyed remove\r\n     * emit true to isDestroyed to remove subscriptions\r\n     * from all streams\r\n     */\r\n    ngOnDestroy() {\r\n\r\n        this.viewportController.removeScrollbar(this);\r\n\r\n        this.isDestroyed$.next(true);\r\n        this.isDestroyed$.complete();\r\n\r\n        this.scrollHelper = null;\r\n        this.thumbMeasure = null;\r\n        this.trackMeasure = null;\r\n        this.viewportMeasure = null;\r\n    }\r\n\r\n    public render() {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n        const track = this.scrollbarTrack.nativeElement;\r\n\r\n        this.renderer.setStyle(thumb, \"display\", \"none\");\r\n        this.trackMeasure.setMeasures(DomHelper.getMeasure(track));\r\n        this.thumbMeasure.setMeasures(DomHelper.getMeasure(thumb));\r\n\r\n        this.renderScrollbarThumb();\r\n        this.moveThumbToPosition();\r\n    }\r\n\r\n    /**\r\n     * a viewport has been added to viewport controller\r\n     */\r\n    private handleViewportLoaded(measure: DomHelper.IScrollContainerMeasure) {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n        const track = this.scrollbarTrack.nativeElement;\r\n        this.thumbMeasure = new ContainerMeasureModel(DomHelper.getMeasure(thumb));\r\n        this.trackMeasure = new ContainerMeasureModel(DomHelper.getMeasure(track));\r\n        this.viewportMeasure = measure;\r\n\r\n        this.initializeScrollHelper();\r\n        this.renderScrollbarThumb();\r\n        this.moveThumbToPosition();\r\n    }\r\n\r\n    /**\r\n     * viewportControl sends update, this could be\r\n     * initialized, scrolled or content changes\r\n     */\r\n    private handleViewportScroll(event: Scrollbar.ScrollEvent) {\r\n\r\n        if (this.scrollHelper.couldSkipScrollEvent(this.scrollDirection, event)) {\r\n            return;\r\n        }\r\n\r\n        this.renderScrollbarThumb();\r\n        this.moveThumbToPosition();\r\n    }\r\n\r\n    /**\r\n     * initialize scroll helpers\r\n     */\r\n    private initializeScrollHelper() {\r\n\r\n        if (!this.scrollHelper) {\r\n            const scrollHelperConstructor = this.scrollDirection === Scrollbar.DIRECTION.X\r\n                ? HorizontalScrollHelper\r\n                : VerticalScrollHelper;\r\n\r\n            this.scrollHelper = new scrollHelperConstructor(this.thumbMeasure, this.trackMeasure, this.viewportMeasure);\r\n        } else {\r\n            this.scrollHelper.viewportMeasure = this.viewportMeasure;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * renders scrollbar thumb\r\n     */\r\n    private renderScrollbarThumb() {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n\r\n        if (!this.scrollHelper.isScrollable()) {\r\n            this.renderer.setStyle(thumb, \"display\", \"none\");\r\n        } else {\r\n            const cssSize = this.scrollHelper.getScrollThumbCssSize();\r\n            this.renderer.removeStyle(thumb, \"display\");\r\n            this.renderer.setStyle(thumb, cssSize.style, cssSize.value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * move thumb to position after viewport has been scrolled\r\n     */\r\n    private moveThumbToPosition() {\r\n        const thumb = this.scrollbarThumb.nativeElement;\r\n        const scrollCSS = this.scrollHelper.getScrollThumbCssTransform();\r\n        this.renderer.setStyle(thumb, scrollCSS.style, scrollCSS.value);\r\n    }\r\n\r\n    /**\r\n     * register scrollbar track click event to scroll a page\r\n     */\r\n    private registerScrollTrackEvents() {\r\n        const track = this.scrollbarTrack.nativeElement;\r\n        fromEvent(track, \"click\")\r\n            .pipe(takeUntil(this.isDestroyed$))\r\n            .subscribe((event: MouseEvent) => {\r\n                if (event.target === this.scrollbarThumb.nativeElement) {\r\n                    return false;\r\n                }\r\n                const offset = this.scrollHelper.calculatePageScroll(DomHelper.getMouseOffset(event));\r\n                this.viewportController.scrollTo(offset);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * handle drag drop on scrollbar thumb\r\n     */\r\n    private registerThumbEvents(): Observable<MouseEvent> {\r\n        const mouseDown$ = fromEvent(this.scrollbarThumb.nativeElement, \"mousedown\");\r\n        const mouseMove$ = fromEvent(this.document, \"mousemove\");\r\n        const mouseUp$ = fromEvent(window, \"mouseup\");\r\n\r\n        const dragDrop$ = mouseDown$.pipe(\r\n            tap(() => this.document.onselectstart = () => false),\r\n            switchMap((dragStart: MouseEvent) => {\r\n                const offset = DomHelper.getElementBounds(this.scrollbarTrack.nativeElement);\r\n                const dragOffset = DomHelper.getMouseOffset(dragStart);\r\n\r\n                this.renderer.addClass(this.hostEl.nativeElement, \"dragged\");\r\n\r\n                /** switch to mousemove stream until we press mouse button */\r\n                return mouseMove$.pipe(\r\n                    tap((dragMove: MouseEvent) => {\r\n                        this.viewportController.scrollTo(\r\n                            this.scrollHelper.calculateDragDropScrollOffset(dragMove, dragOffset, offset)\r\n                        );\r\n                    }),\r\n                    finalize(() => {\r\n                        this.document.onselectstart = null;\r\n                        this.renderer.removeClass(this.hostEl.nativeElement, \"dragged\");\r\n                    }),\r\n                    takeUntil(mouseUp$),\r\n                );\r\n            })\r\n        );\r\n        return dragDrop$.pipe(takeUntil(this.isDestroyed$));\r\n    }\r\n}\r\n","<div class=\"scrollbar-up\" #scrollbarTopLeft></div>\r\n<div class=\"scrollbar-track\" #scrollbarTrack>\r\n    <div class=\"scrollbar-thumb\" #scrollbarThumb></div>\r\n</div>\r\n<div class=\"scrollbar-up\" #scrollbarRightBottom></div>\r\n","import { Directive, ViewContainerRef, TemplateRef, Input } from \"@angular/core\";\r\nimport { Platform } from \"@angular/cdk/platform\";\r\n\r\n/**\r\n * dont show element if we can support styles of scrollbar\r\n * only via css. Possible with webkit / BLINK (chrome, chromium, opera)\r\n */\r\n@Directive({ selector: \"[ngxCustomScrollbarHideOnNativeStyle]\"})\r\nexport class NgxCustomScrollbarHideOnNativeStyleDirective {\r\n\r\n    constructor(\r\n        /** The view container to add items to. */\r\n        private viewContainerRef: ViewContainerRef,\r\n        /** The template to use when stamping out new items. */\r\n        private template: TemplateRef<any>,\r\n        /** platform */\r\n        private platform: Platform\r\n    ) { }\r\n\r\n    @Input()\r\n    set q2gScrollbarHideOnNativeStyle(hideOnNative: boolean) {\r\n        if (!this.platform.WEBKIT && !this.platform.BLINK || hideOnNative === false) {\r\n            this.viewContainerRef.createEmbeddedView(this.template);\r\n        } else {\r\n            this.viewContainerRef.clear();\r\n        }\r\n    }\r\n}\r\n","import { Scrollbar } from \"../api/scrollbar.interface\";\r\nimport { Subject } from \"rxjs\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { IViewportControl } from \"../api/viewport-control.interface\";\r\n\r\nexport abstract class Viewport implements Scrollbar.IScrollbarViewport {\r\n\r\n    protected viewportScrolledOffset = { top: 0, left: 0 };\r\n\r\n    protected scrolled$: Subject<void> = new Subject();\r\n\r\n    protected viewPortController: IViewportControl;\r\n\r\n    abstract measureSize(): DomHelper.IScrollContainerMeasure;\r\n\r\n    abstract get scrolledOffset();\r\n\r\n    abstract scrollTo(offset: Scrollbar.IOffset);\r\n\r\n    public destroy() { /* noop */ }\r\n\r\n    public init() { /** noop */ }\r\n\r\n    public set control(control: IViewportControl) {\r\n        this.viewPortController = control;\r\n    }\r\n\r\n    public get control(): IViewportControl {\r\n        return this.viewPortController;\r\n    }\r\n\r\n    public reset() {\r\n        this.scrollTo({top: 0, left: 0});\r\n    }\r\n\r\n    public onScrolled() {\r\n        return this.scrolled$.asObservable();\r\n    }\r\n}\r\n","import { NgZone } from \"@angular/core\";\r\nimport { supportsScrollBehavior } from \"@angular/cdk/platform\";\r\nimport { fromEvent, Observable, Subject } from \"rxjs\";\r\nimport { takeUntil } from \"rxjs/operators\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { Viewport } from \"./viewport\";\r\nimport { Scrollbar } from \"../api/scrollbar.interface\";\r\n\r\nexport class HtmlViewport extends Viewport {\r\n\r\n    /**\r\n     * stream to register on native scroll events\r\n     */\r\n    private scroll$: Observable<Event>;\r\n\r\n    private destroy$: Subject<boolean>;\r\n\r\n    private isDestroyed = false;\r\n\r\n    public constructor(\r\n        private zone: NgZone,\r\n        private element: HTMLElement\r\n    ) {\r\n        super();\r\n        this.destroy$ = new Subject();\r\n    }\r\n\r\n    /** element is bound to viewport */\r\n    public init() {\r\n\r\n        this.scroll$ = fromEvent(this.element, \"scroll\")\r\n            .pipe(takeUntil(this.destroy$));\r\n\r\n        this.registerEvents();\r\n    }\r\n\r\n    public destroy() {\r\n\r\n        /**\r\n         * component gets allready destroyed\r\n         * could happens twice if we create this with directive which destroys the viewport\r\n         * or we destroy the whole component which provides viewport control\r\n         */\r\n        if (this.isDestroyed) {\r\n            return;\r\n        }\r\n\r\n        this.destroy$.next(true);\r\n        this.destroy$.complete();\r\n        this.isDestroyed = true;\r\n    }\r\n\r\n    /**\r\n     * get container dimensions\r\n     */\r\n    public measureSize(): DomHelper.IScrollContainerMeasure {\r\n        return DomHelper.getScrollContainerMeasure(this.element);\r\n    }\r\n\r\n    /**\r\n     * scroll viewport to specific position\r\n     */\r\n    public scrollTo(offset: Scrollbar.IOffset) {\r\n        if (supportsScrollBehavior()) {\r\n            this.element.scrollTo(offset);\r\n        } else {\r\n            const { top, left } = offset;\r\n            if (left || left === 0) {\r\n                this.element.scrollLeft = left;\r\n            }\r\n            if (top || top === 0) {\r\n                this.element.scrollTop = top;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get scrolled offset\r\n     */\r\n    public get scrolledOffset() {\r\n        return {\r\n            top: this.element.scrollTop,\r\n            left: this.element.scrollLeft\r\n        };\r\n    }\r\n\r\n    /**\r\n     * register to scroll event on html node\r\n     */\r\n    private registerEvents() {\r\n        this.zone.runOutsideAngular(() => {\r\n            this.scroll$.subscribe(() => {\r\n                if (!this.viewPortController.disabled) {\r\n                    this.scrolled$.next();\r\n                    return;\r\n                }\r\n                this.scrollTo({ left: 0, top: 0 });\r\n            });\r\n        });\r\n    }\r\n}\r\n","import { Directive, NgZone, Host, ElementRef, OnDestroy, OnInit, AfterViewChecked, AfterViewInit, Input, Renderer2 } from \"@angular/core\";\r\nimport { ViewportControl } from \"../provider/viewport.control\";\r\nimport { HtmlViewport } from \"../viewport/html.viewport\";\r\nimport { Subject, fromEvent } from \"rxjs\";\r\nimport { filter, takeUntil, delay, distinctUntilChanged } from \"rxjs/operators\";\r\n\r\ninterface ContainerScrollSize {\r\n    scrollHeight: number;\r\n    scrollWidth: number;\r\n}\r\n\r\nenum CHANGE_DETECTION_STRATEGY {\r\n    CHECKED  = \"checked\", // change detection\r\n    INPUT    = \"input\",\r\n    MUTATION = \"mutation\"\r\n}\r\n\r\n/**\r\n * directive for html elements\r\n * this will wrap the html element into HtmlViewport\r\n */\r\n@Directive({\r\n    selector: \"[ngxCustomScrollbarScrollable]\",\r\n    exportAs: \"ngxCustomScrollbarHTMLViewport\"\r\n})\r\nexport class NgxCustomScrollbarScrollableDirective implements AfterViewInit, AfterViewChecked, OnDestroy, OnInit {\r\n\r\n    private htmlViewport: HtmlViewport;\r\n\r\n    private scrollSize: ContainerScrollSize;\r\n\r\n    private update$: Subject<ContainerScrollSize> = new Subject();\r\n\r\n    private changeDetection: CHANGE_DETECTION_STRATEGY = CHANGE_DETECTION_STRATEGY.CHECKED;\r\n\r\n    private destroyed$: Subject<boolean> = new Subject();\r\n\r\n    private oldScrollDimension = null;\r\n\r\n    constructor(\r\n        @Host() private viewportControl: ViewportControl,\r\n        private zone: NgZone,\r\n        private el: ElementRef,\r\n        private renderer: Renderer2\r\n    ) {}\r\n\r\n    @Input(\"ngxCustomScrollbarScrollable\")\r\n    public set changeDetectionStrategy(strategy: CHANGE_DETECTION_STRATEGY) {\r\n        if (strategy) {\r\n            this.changeDetection = strategy;\r\n        }\r\n    }\r\n\r\n    ngOnInit() {\r\n        this.renderer.addClass(this.el.nativeElement, \"ngx-customscrollbar--html-viewport\");\r\n        this.update$.pipe(\r\n            distinctUntilChanged(),\r\n            delay(100),\r\n            filter((newSize) => {\r\n                const hasChanged = JSON.stringify(newSize) !== JSON.stringify(this.scrollSize);\r\n                this.scrollSize = newSize;\r\n                return hasChanged;\r\n            }),\r\n            takeUntil(this.destroyed$)\r\n        ).subscribe({\r\n            next: () => this.viewportControl.update()\r\n        });\r\n\r\n        switch (this.changeDetection) {\r\n            case CHANGE_DETECTION_STRATEGY.INPUT:\r\n                this.initInputChangeDetection();\r\n                break;\r\n        }\r\n    }\r\n\r\n    ngAfterViewChecked() {\r\n        if (this.changeDetection === CHANGE_DETECTION_STRATEGY.CHECKED) {\r\n            const newScrollDimension = this.getScrollDimension();\r\n            if (this.oldScrollDimension && JSON.stringify(this.oldScrollDimension) === JSON.stringify(newScrollDimension)) {\r\n                return;\r\n            }\r\n            this.oldScrollDimension = newScrollDimension;\r\n            this.update$.next(newScrollDimension);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * if component gets destroyed tell our control we gets destroyed\r\n     * and remove from dom mutations\r\n     *\r\n     * @memberof ScrollableContainerDirective\r\n     */\r\n    ngOnDestroy() {\r\n        this.htmlViewport.destroy();\r\n        this.viewportControl = null;\r\n        this.update$.complete();\r\n        this.update$ = null;\r\n\r\n        this.destroyed$.next(true);\r\n        this.destroyed$.complete();\r\n        this.destroyed$ = null;\r\n    }\r\n\r\n    /**\r\n     * start watching the dom after view has been initialized\r\n     * this ensures initial data has allready been set.\r\n     *\r\n     * We only want to know if we add or remove some items\r\n     *\r\n     * @memberof ScrollableContainerDirective\r\n     */\r\n    ngAfterViewInit(): void {\r\n        this.scrollSize   = this.getScrollDimension();\r\n        this.htmlViewport = new HtmlViewport(this.zone, this.el.nativeElement);\r\n        this.viewportControl.viewPort = this.htmlViewport;\r\n    }\r\n\r\n    /**\r\n     * get scroll dimensions\r\n     */\r\n    private getScrollDimension(): ContainerScrollSize {\r\n        return {\r\n            scrollHeight: this.el.nativeElement.scrollHeight,\r\n            scrollWidth: this.el.nativeElement.scrollWidth\r\n        };\r\n    }\r\n\r\n    private initInputChangeDetection() {\r\n        fromEvent(this.el.nativeElement, \"input\")\r\n            .pipe(takeUntil(this.destroyed$))\r\n            .subscribe({\r\n                next: () => this.update$.next(this.getScrollDimension())\r\n            });\r\n    }\r\n}\r\n","export class Overflow {\r\n    public static readonly NONE   = \"none\";\r\n    public static readonly AUTO   = \"auto\";\r\n    public static readonly SCROLL = \"scroll\";\r\n}\r\n","import { ViewContainerRef, TemplateRef, Host, DoCheck, OnInit, OnDestroy, ChangeDetectorRef, Directive } from \"@angular/core\";\r\nimport { switchMap, tap, takeUntil } from \"rxjs/operators\";\r\nimport { Subject } from \"rxjs\";\r\nimport { Scrollbar } from \"../api/scrollbar.interface\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { Overflow } from \"../model/overflow\";\r\nimport { ViewportControl } from \"../provider/viewport.control\";\r\n\r\n/**\r\n * remove component if we dont need to scroll anymore, and\r\n * show it again if we can scroll. Same as css overflow: auto\r\n */\r\n@Directive()\nexport abstract class NgxCustomScrollbarOverflow implements DoCheck, OnDestroy, OnInit {\r\n\r\n    protected overflow: Overflow = Overflow.SCROLL;\r\n\r\n    private isViewportVisible = false;\r\n    private needsUpdate: boolean;\r\n    private destroyed$: Subject<boolean>;\r\n\r\n    constructor(\r\n        /** The view container to add items to. */\r\n        private viewContainerRef: ViewContainerRef,\r\n\r\n        /** The template to use when stamping out new items. */\r\n        private template: TemplateRef<any>,\r\n        /** viewport control to bound */\r\n\r\n        @Host() protected viewportController: ViewportControl,\r\n        private changeDetector: ChangeDetectorRef\r\n    ) {\r\n        this.needsUpdate = false;\r\n        this.destroyed$ = new Subject();\r\n    }\r\n\r\n    /**\r\n     * angular change detection hook\r\n     */\r\n    ngDoCheck() {\r\n        if (this.needsUpdate) {\r\n            this.toggleScrollbar();\r\n        }\r\n        this.needsUpdate = false;\r\n    }\r\n\r\n    /**\r\n     * scrollbar gets destroyed\r\n     */\r\n    ngOnDestroy() {\r\n        this.destroyed$.next(true);\r\n    }\r\n\r\n    /**\r\n     * register on viewportControl onUpdate event\r\n     * and check scrollbar for visibility\r\n     */\r\n    ngOnInit() {\r\n        this.viewportController.onLoad().pipe(\r\n            tap(() => this.checkScrollbarNeedsUpdate()),\r\n            switchMap(() => this.viewportController.onUpdate()),\r\n            takeUntil(this.destroyed$)\r\n        ).subscribe((updateEvent) => {\r\n            const event = updateEvent.type;\r\n            const checkUpdate = event === Scrollbar.VIEWPORT_EVENT.UPDATE;\r\n\r\n            if (checkUpdate) {\r\n                this.checkScrollbarNeedsUpdate();\r\n            }\r\n        });\r\n    }\r\n\r\n    protected abstract hasOverflow(dimensions: DomHelper.IScrollContainerMeasure): boolean;\r\n\r\n    /**\r\n     * check for updates on scrollbar\r\n     */\r\n    protected checkScrollbarNeedsUpdate() {\r\n\r\n        let isOverflow: boolean;\r\n\r\n        switch (this.overflow) {\r\n            case Overflow.NONE: isOverflow = false; break;\r\n            case Overflow.SCROLL: isOverflow = true; break;\r\n            default: isOverflow = this.hasOverflow(this.viewportController.viewportDimension);\r\n        }\r\n\r\n        this.needsUpdate = isOverflow !== this.isViewportVisible;\r\n        this.isViewportVisible = isOverflow;\r\n\r\n        if (this.needsUpdate) {\r\n            this.changeDetector.detectChanges();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * toggle scrollbar visibility, clears viewport\r\n     * if scrollbar should be hidden now\r\n     */\r\n    private toggleScrollbar() {\r\n        if (this.isViewportVisible) {\r\n            this.viewContainerRef.createEmbeddedView(this.template);\r\n        } else {\r\n            this.viewContainerRef.clear();\r\n        }\r\n    }\r\n}\r\n","import { Directive, Input} from \"@angular/core\";\r\nimport { NgxCustomScrollbarOverflow } from \"./overflow-auto\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { Overflow } from \"../model/overflow\";\r\n\r\n/**\r\n * remove component if no overflow on y axis\r\n */\r\n@Directive({selector: \"[ngxCustomScrollbarOverflowY]\"})\r\nexport class NgxCustomScrollbarOverflowYDirective extends NgxCustomScrollbarOverflow {\r\n\r\n    @Input()\r\n    public set ngxCustomScrollbarOverflowY(overflow: \"none\" | \"auto\" | \"scroll\") {\r\n        if (overflow === Overflow.NONE) {\r\n            this.viewportController.disableScroll(true);\r\n        }\r\n        this.overflow = overflow;\r\n    }\r\n\r\n    protected hasOverflow(viewportDimension: DomHelper.IScrollContainerMeasure): boolean {\r\n        return viewportDimension.scrollHeight > viewportDimension.height;\r\n    }\r\n}\r\n","\r\nimport { Directive, Input} from \"@angular/core\";\r\nimport { DomHelper } from \"../helper/dom.helper\";\r\nimport { Overflow } from \"../model/overflow\";\r\nimport { NgxCustomScrollbarOverflow } from \"./overflow-auto\";\r\n\r\n/**\r\n * renders component only if the viewport is overflows in x axis\r\n * otherwise remove / dont render it\r\n */\r\n@Directive({ selector: \"[ngxCustomScrollbarOverflowX]\" })\r\nexport class NgxCustomScrollbarOverflowXDirective extends NgxCustomScrollbarOverflow {\r\n\r\n    @Input()\r\n    public set ngxCustomScrollbarOverflowX(overflow: Overflow) {\r\n        this.overflow = overflow;\r\n    }\r\n\r\n    protected hasOverflow(viewportDimension: DomHelper.IScrollContainerMeasure): boolean {\r\n        return viewportDimension.scrollWidth > viewportDimension.width;\r\n    }\r\n}\r\n","import { NgModule } from \"@angular/core\";\r\nimport { CommonModule } from \"@angular/common\";\r\nimport { NgxCustomScrollbarComponent} from \"./components/scrollbar.component\";\r\nimport { NgxCustomScrollbarHideOnNativeStyleDirective } from \"./directives/no-native-style.directive\";\r\nimport { NgxCustomScrollbarScrollableDirective } from \"./directives/scrollable-container.directive\";\r\nimport { NgxCustomScrollbarOverflowYDirective } from \"./directives/overflow-y.directive\";\r\nimport { NgxCustomScrollbarOverflowXDirective } from \"./directives/overflow-x.directive\";\r\nimport { ViewportControl } from \"./provider/viewport.control\";\r\n\r\n@NgModule({\r\n    declarations: [\r\n        NgxCustomScrollbarComponent,\r\n        NgxCustomScrollbarHideOnNativeStyleDirective,\r\n        NgxCustomScrollbarOverflowXDirective,\r\n        NgxCustomScrollbarOverflowYDirective,\r\n        NgxCustomScrollbarScrollableDirective,\r\n    ],\r\n    exports: [\r\n        NgxCustomScrollbarComponent,\r\n        NgxCustomScrollbarHideOnNativeStyleDirective,\r\n        NgxCustomScrollbarOverflowXDirective,\r\n        NgxCustomScrollbarOverflowYDirective,\r\n        NgxCustomScrollbarScrollableDirective,\r\n    ],\r\n    imports: [\r\n        CommonModule,\r\n    ],\r\n    providers: [\r\n        ViewportControl\r\n    ]\r\n})\r\nexport class NgxCustomScrollbarModule { }\r\n","/*\r\n * Public API Surface of scrollbars\r\n */\r\nexport * from \"./ngx-customscrollbars/custom-scrollbars.module\";\r\nexport * from \"./ngx-customscrollbars/helper/dom.helper\";\r\nexport * from \"./ngx-customscrollbars/model/overflow\";\r\nexport * from \"./ngx-customscrollbars/provider/viewport.control\";\r\nexport * from \"./ngx-customscrollbars/provider/window-resize\";\r\nexport * from \"./ngx-customscrollbars/viewport/viewport\";\r\nexport * from \"./ngx-customscrollbars/directives/scrollable-container.directive\"\r\nexport * from \"./ngx-customscrollbars/directives/overflow-x.directive\"\r\nexport * from \"./ngx-customscrollbars/directives/overflow-y.directive\"\r\nexport * from \"./ngx-customscrollbars/directives/no-native-style.directive\"\r\nexport * from \"./ngx-customscrollbars/components/scrollbar.component\"","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":["i1.WindowResize","takeUntil","i1.ViewportControl"],"mappings":"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"}}}